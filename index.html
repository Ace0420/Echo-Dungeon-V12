<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Echo Dungeon V11 - Blind First Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            color: #fff;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        
        #micButton {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #111;
            border: none;
            cursor: pointer;
            transition: background 0.3s;
            outline: none;
        }
        
        #micButton:active {
            background: #333;
        }
        
        #micButton.listening {
            background: #003300;
        }
        
        #micButton.processing {
            background: #000033;
        }
        
        #micButton.start-button {
            background: #000022;
        }
        
        /* Screen reader accessible, visually hidden */
        #textDisplay {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
    </style>
</head>
<body>
    <div id="textDisplay" role="status" aria-live="polite"></div>
    <button id="micButton" class="start-button" onclick="handleClick()" aria-label="Voice command button - Tap to speak"></button>

    <script>
        // ============================================================
        // ECHO DUNGEON V11 - COMPLETE GAME
        // A Voice-Controlled Dungeon Crawler for Blind Players
        // Copyright 2025 Asa Hartz Games - FREE for the community
        // ============================================================

        // ------------------------------------------------------------
        // SECTION 1: CORE REFERENCES AND BROWSER SUPPORT
        // ------------------------------------------------------------
        
        const micButton = document.getElementById('micButton');
        const textDisplay = document.getElementById('textDisplay');
        
        let browserSupport = {
            speechSynthesis: false,
            speechRecognition: false,
            https: false
        };
        
        function checkBrowserSupport() {
            browserSupport.https = window.location.protocol === 'https:' || window.location.hostname === 'localhost';
            browserSupport.speechSynthesis = !!(window.speechSynthesis && window.SpeechSynthesisUtterance);
            browserSupport.speechRecognition = !!(window.webkitSpeechRecognition || window.SpeechRecognition);
        }

        // ------------------------------------------------------------
        // SECTION 2: MASTER GAME STATE
        // ------------------------------------------------------------
        
        const game = {
            player: {
                name: '',
                class: '',
                level: 1,
                experience: 0,
                experienceToNext: 100,
                health: 100,
                maxHealth: 100,
                mana: 50,
                maxMana: 50,
                gold: 25,
                inventory: [],
                equippedRings: [],
                equippedBracelets: [],  // NEW: Array like rings, up to 10
                learnedAbilities: [],
                equippedAmulet: '',
                position: { x: 6, y: 6 },
                baseAttack: 15,
                defense: 0,
                weapon: '',
                armor: '',
                shield: '',
                helmet: '',
                gloves: '',
                boots: '',
                specialItems: [],
                activeEffects: [],
                junkBag: [],
                // Scaling multipliers (increase every 10 floors)
                damageMultiplier: 1,
                defenseMultiplier: 1,
                manaMultiplier: 1
            },
            dungeon: {
                grid: {},
                size: 12,
                currentLevel: 1,
                hasSecretRoom: false,
                secretRoom: null
            },
            currentRoom: null,
            combat: null,
            listening: false,
            started: false,
            needsClass: true,
            initialized: false,
            phase: 'init',
            merchantOpen: false,
            recognition: null,
            saveCounter: 0
        };

        // ------------------------------------------------------------
        // SECTION 3: CLASS DEFINITIONS
        // ------------------------------------------------------------
        
        const classes = {
            warrior: {
                name: 'Warrior',
                health: 120,
                maxHealth: 120,
                mana: 30,
                maxMana: 30,
                gold: 50,
                items: ['Steel Sword', 'Health Potion', 'Health Potion', 'Chainmail', 'Iron Shield'],
                special: { name: 'Power Strike', damage: 100, cost: 15, type: 'damage' }
            },
            mage: {
                name: 'Mage',
                health: 80,
                maxHealth: 80,
                mana: 100,
                maxMana: 100,
                gold: 75,
                items: ['Mystic Staff', 'Mana Potion', 'Health Potion', 'Enchanted Robes'],
                special: { name: 'Fireball', damage: 100, cost: 20, type: 'damage' }
            },
            rogue: {
                name: 'Rogue',
                health: 100,
                maxHealth: 100,
                mana: 60,
                maxMana: 60,
                gold: 100,
                items: ['Shadow Daggers', 'Lockpicks', 'Health Potion', 'Shadow Leather'],
                special: { name: 'Backstab', damage: 75, cost: 15, type: 'damage' }
            }
        };

        // ------------------------------------------------------------
        // SECTION 4: EQUIPMENT DATA - WEAPONS
        // ------------------------------------------------------------
        
        const weapons = [
            { name: 'Steel Sword', attack: 12, class: 'warrior', value: 100 },
            { name: 'Mystic Staff', attack: 8, mana: 15, class: 'mage', value: 150 },
            { name: 'Shadow Daggers', attack: 10, class: 'rogue', value: 120 },
            { name: 'Legendary Greatsword', attack: 25, class: 'warrior', value: 300 },
            { name: 'Archmage Staff', attack: 12, mana: 25, class: 'mage', value: 350 },
            { name: 'Vorpal Daggers', attack: 16, class: 'rogue', value: 320 },
            { name: 'Demon Slayer Blade', attack: 40, class: 'warrior', value: 500 },
            { name: 'Staff of the Cosmos', attack: 15, mana: 35, class: 'mage', value: 600 },
            { name: 'Ethereal Blades', attack: 22, class: 'rogue', value: 550 },
            { name: 'Godslayer Greatsword', attack: 30, class: 'warrior', value: 1000, minLevel: 6 },
            { name: 'Staff of Eternity', attack: 20, mana: 45, class: 'mage', value: 1200, minLevel: 6 },
            { name: 'Nightfall Daggers', attack: 32, class: 'rogue', value: 1100, minLevel: 6 },
            { name: 'Excalibur', attack: 50, class: 'warrior', value: 2000, minLevel: 8 },
            { name: 'Infinity Staff', attack: 25, mana: 60, class: 'mage', value: 2500, minLevel: 8 },
            { name: 'Oblivion Blades', attack: 42, class: 'rogue', value: 2200, minLevel: 8 },
            { name: 'Sword of the Ancients', attack: 70, class: 'warrior', value: 5000, minLevel: 10 },
            { name: 'Cosmic Scepter', attack: 35, mana: 80, class: 'mage', value: 6000, minLevel: 10 },
            { name: 'Void Assassin Blades', attack: 60, class: 'rogue', value: 5500, minLevel: 10 },
            { name: 'Ragnarok', attack: 100, class: 'warrior', value: 10000, minLevel: 20 },
            { name: 'Genesis Staff', attack: 50, mana: 120, class: 'mage', value: 12000, minLevel: 20 },
            { name: 'Apocalypse Daggers', attack: 85, class: 'rogue', value: 11000, minLevel: 20 }
        ];

        // ------------------------------------------------------------
        // SECTION 5: EQUIPMENT DATA - ARMOR
        // ------------------------------------------------------------
        
        const armors = [
            { name: 'Chainmail', defense: 10, class: 'warrior', value: 100 },
            { name: 'Enchanted Robes', defense: 5, mana: 10, class: 'mage', value: 120 },
            { name: 'Shadow Leather', defense: 6, class: 'rogue', value: 110 },
            { name: 'Dragonscale Plate', defense: 15, class: 'warrior', value: 350 },
            { name: 'Arcane Vestments', defense: 12, mana: 20, class: 'mage', value: 380 },
            { name: 'Phantom Suit', defense: 13, class: 'rogue', value: 360 },
            { name: 'Titanium Fortress', defense: 27, class: 'warrior', value: 550 },
            { name: 'Celestial Robes', defense: 18, mana: 25, class: 'mage', value: 600 },
            { name: 'Void Cloak', defense: 20, class: 'rogue', value: 580 },
            { name: 'Divine Plate', defense: 35, class: 'warrior', value: 1200, minLevel: 6 },
            { name: 'Robes of the Archmage', defense: 28, mana: 40, class: 'mage', value: 1100, minLevel: 6 },
            { name: 'Shadowweave Armor', defense: 30, class: 'rogue', value: 1150, minLevel: 6 },
            { name: 'Immortal Armor', defense: 50, class: 'warrior', value: 3000, minLevel: 8 },
            { name: 'Vestments of Infinity', defense: 40, mana: 60, class: 'mage', value: 2800, minLevel: 8 },
            { name: 'Cloak of Eternity', defense: 45, class: 'rogue', value: 2900, minLevel: 8 },
            { name: 'Armor of the Titans', defense: 70, class: 'warrior', value: 6000, minLevel: 10 },
            { name: 'Cosmic Vestments', defense: 55, mana: 90, class: 'mage', value: 7000, minLevel: 10 },
            { name: 'Void Emperor Cloak', defense: 65, class: 'rogue', value: 6500, minLevel: 10 },
            { name: 'Armor of Ragnarok', defense: 100, class: 'warrior', value: 12000, minLevel: 20 },
            { name: 'Genesis Robes', defense: 80, mana: 150, class: 'mage', value: 14000, minLevel: 20 },
            { name: 'Apocalypse Suit', defense: 90, class: 'rogue', value: 13000, minLevel: 20 }
        ];

        // ------------------------------------------------------------
        // SECTION 6: EQUIPMENT DATA - SHIELDS
        // ------------------------------------------------------------
        
        const shields = [
            { name: 'Iron Shield', defense: 5, class: 'warrior', value: 80 },
            { name: 'Tower Shield', defense: 10, class: 'warrior', value: 250 },
            { name: 'Aegis Shield', defense: 15, class: 'warrior', value: 450 },
            { name: 'Shield of Heroes', defense: 25, class: 'warrior', value: 800, minLevel: 6 },
            { name: 'Bulwark of Ages', defense: 35, class: 'warrior', value: 1500, minLevel: 8 },
            { name: 'Titan Shield', defense: 50, class: 'warrior', value: 4000, minLevel: 10 },
            { name: 'Shield of Ragnarok', defense: 75, class: 'warrior', value: 10000, minLevel: 20 }
        ];

        // ------------------------------------------------------------
        // SECTION 7: EQUIPMENT DATA - HELMETS
        // ------------------------------------------------------------
        
        const helmets = [
            { name: 'Iron Helm', defense: 3, class: 'warrior', value: 50 },
            { name: 'Mage Hood', mana: 50, class: 'mage', value: 60 },
            { name: 'Shadow Mask', mana: 30, class: 'rogue', value: 55 },
            { name: 'Crown of Kings', defense: 38, class: 'warrior', value: 300, minLevel: 5 },
            { name: 'Circlet of Wisdom', mana: 120, class: 'mage', value: 350, minLevel: 5 },
            { name: 'Assassin Hood', mana: 50, class: 'rogue', value: 320, minLevel: 5 },
            { name: 'Helm of the Ancients', defense: 55, class: 'warrior', value: 3000, minLevel: 10 },
            { name: 'Crown of Cosmic Power', mana: 200, class: 'mage', value: 3500, minLevel: 10 },
            { name: 'Void Assassin Mask', mana: 150, class: 'rogue', value: 3200, minLevel: 10 },
            { name: 'Helm of Ragnarok', defense: 80, class: 'warrior', value: 8000, minLevel: 20 },
            { name: 'Genesis Crown', mana: 300, class: 'mage', value: 9000, minLevel: 20 },
            { name: 'Apocalypse Hood', mana: 250, class: 'rogue', value: 8500, minLevel: 20 }
        ];

        // ------------------------------------------------------------
        // SECTION 8: EQUIPMENT DATA - GLOVES
        // ------------------------------------------------------------
        
        const gloves = [
            { name: 'Leather Gloves', attack: 12, value: 40 },
            { name: 'Gauntlets of Strength', attack: 55, class: 'warrior', value: 200, minLevel: 4 },
            { name: 'Gloves of Casting', mana: 80, class: 'mage', value: 220, minLevel: 4 },
            { name: 'Shadow Grips', attack: 14, health: 30, class: 'rogue', value: 210, minLevel: 4 },
            { name: 'Titan Gauntlets', attack: 80, class: 'warrior', value: 2500, minLevel: 10 },
            { name: 'Cosmic Gloves', mana: 180, class: 'mage', value: 3000, minLevel: 10 },
            { name: 'Void Grips', attack: 70, health: 100, class: 'rogue', value: 2800, minLevel: 10 },
            { name: 'Gauntlets of Ragnarok', attack: 120, class: 'warrior', value: 7000, minLevel: 20 },
            { name: 'Genesis Gloves', mana: 280, class: 'mage', value: 8000, minLevel: 20 },
            { name: 'Apocalypse Grips', attack: 110, health: 200, class: 'rogue', value: 7500, minLevel: 20 }
        ];

        // ------------------------------------------------------------
        // SECTION 9: EQUIPMENT DATA - BOOTS
        // ------------------------------------------------------------
        
        const boots = [
            { name: 'Iron Boots', defense: 12, value: 35 },
            { name: 'Boots of Speed', mana: 15, value: 150, minLevel: 3 },
            { name: 'Greaves of the Titan', defense: 38, class: 'warrior', value: 300, minLevel: 5 },
            { name: 'Slippers of Wisdom', mana: 70, class: 'mage', value: 280, minLevel: 5 },
            { name: 'Boots of Shadow', health: 25, class: 'rogue', value: 320, minLevel: 5 },
            { name: 'Ancient Greaves', defense: 60, class: 'warrior', value: 2800, minLevel: 10 },
            { name: 'Cosmic Slippers', mana: 170, class: 'mage', value: 3200, minLevel: 10 },
            { name: 'Void Treads', health: 120, class: 'rogue', value: 3000, minLevel: 10 },
            { name: 'Greaves of Ragnarok', defense: 90, class: 'warrior', value: 7500, minLevel: 20 },
            { name: 'Genesis Slippers', mana: 270, class: 'mage', value: 8500, minLevel: 20 },
            { name: 'Apocalypse Boots', health: 250, class: 'rogue', value: 8000, minLevel: 20 }
        ];

        // ------------------------------------------------------------
        // SECTION 10: EQUIPMENT DATA - BRACELETS (Ring-Style System)
        // Now supports up to 10 equipped, stacking bonuses
        // ------------------------------------------------------------
        
        const bracelets = [
            { name: 'Bronze Bracelet', attack: 5, mana: 0, value: 100 },
            { name: 'Silver Bracelet', attack: 10, mana: 20, value: 300, minLevel: 3 },
            { name: 'Gold Bracelet', attack: 15, mana: 40, value: 800, minLevel: 5 },
            { name: 'Platinum Bracelet', attack: 25, mana: 70, value: 2000, minLevel: 8 },
            { name: 'Ancient Bracelet', attack: 40, mana: 120, value: 5000, minLevel: 10 },
            { name: 'Cosmic Bracelet', attack: 60, mana: 180, value: 10000, minLevel: 15 },
            { name: 'Bracelet of the Cosmos', attack: 80, mana: 200, value: 15000, minLevel: 18 },
            { name: 'Bracelet of Ragnarok', attack: 90, mana: 250, value: 20000, minLevel: 20 },
            { name: 'Bracelet of Annihilation', attack: 150, mana: 350, value: 50000, minLevel: 25 }
        ];

        // ------------------------------------------------------------
        // SECTION 11: RINGS DATA
        // ------------------------------------------------------------
        
        const rings = [
            { name: 'Ring of Vitality', effect: '+10 Max Health', stat: 'maxHealth', value: 10 },
            { name: 'Ring of Minor Mana', effect: '+40 Max Mana', stat: 'maxMana', value: 40 },
            { name: 'Ring of Protection', effect: '+50 Max Health', stat: 'maxHealth', value: 50 },
            { name: 'Ring of Strength', effect: '+4 Attack Damage', stat: 'attack', value: 4 },
            { name: 'Ring of Wisdom', effect: '+8 Max Mana', stat: 'maxMana', value: 8 },
            { name: 'Ring of the Titan', effect: '+20 Max Health', stat: 'maxHealth', value: 20 },
            { name: 'Ring of Arcane Power', effect: '+15 Max Mana', stat: 'maxMana', value: 15 },
            { name: 'Ring of the Berserker', effect: '+6 Attack Damage', stat: 'attack', value: 6 },
            { name: 'Ring of Regeneration', effect: 'Restore 50 HP per combat turn', stat: 'regen', value: 50 },
            { name: 'Ancient Ring', effect: '+50 Max Health', stat: 'maxHealth', value: 50, minLevel: 10 },
            { name: 'Cosmic Ring', effect: '+80 Max Mana', stat: 'maxMana', value: 80, minLevel: 10 },
            { name: 'Ring of Devastation', effect: '+15 Attack Damage', stat: 'attack', value: 15, minLevel: 10 },
            { name: 'Ragnarok Ring', effect: '+120 Max Health', stat: 'maxHealth', value: 120, minLevel: 20 },
            { name: 'Genesis Ring', effect: '+150 Max Mana', stat: 'maxMana', value: 150, minLevel: 20 },
            { name: 'Apocalypse Ring', effect: '+30 Attack Damage', stat: 'attack', value: 30, minLevel: 20 }
        ];

        // ------------------------------------------------------------
        // SECTION 12: AMULETS DATA
        // ------------------------------------------------------------
        
        const amulets = [
            { name: 'Amulet of Vitality', effect: '+15 Max Health', stat: 'maxHealth', value: 15 },
            { name: 'Amulet of Mana', effect: '+15 Max Mana', stat: 'maxMana', value: 15 },
            { name: 'Amulet of Experience', effect: '+20% Experience Gain', stat: 'expGain', value: 20 },
            { name: 'Amulet of the Archmage', effect: '+30 Max Mana', stat: 'maxMana', value: 30 },
            { name: 'Amulet of the Titan', effect: '+30 Max Health', stat: 'maxHealth', value: 30 },
            { name: 'Amulet of Power', effect: '+5 Attack', stat: 'attack', value: 5 },
            { name: 'Ancient Amulet', effect: '+60 Max Health', stat: 'maxHealth', value: 60, minLevel: 10 },
            { name: 'Cosmic Amulet', effect: '+100 Max Mana', stat: 'maxMana', value: 100, minLevel: 10 },
            { name: 'Amulet of Destruction', effect: '+20 Attack', stat: 'attack', value: 20, minLevel: 10 },
            { name: 'Ragnarok Amulet', effect: '+150 Max Health', stat: 'maxHealth', value: 150, minLevel: 20 },
            { name: 'Genesis Amulet', effect: '+200 Max Mana', stat: 'maxMana', value: 200, minLevel: 20 },
            { name: 'Apocalypse Amulet', effect: '+50 Attack', stat: 'attack', value: 50, minLevel: 20 }
        ];

        // ------------------------------------------------------------
        // SECTION 13: TREASURES DATA
        // ------------------------------------------------------------
        
        const treasures = [
            { name: 'Sapphire Gem', value: 50 },
            { name: 'Ruby Gem', value: 75 },
            { name: 'Diamond', value: 100 },
            { name: 'Emerald', value: 60 },
            { name: 'Ancient Coin Collection', value: 40 },
            { name: 'Golden Chalice', value: 80 },
            { name: 'Silver Crown', value: 90 },
            { name: 'Enchanted Amulet', value: 120 }
        ];

        // ------------------------------------------------------------
        // END OF PIECE 1
        // Piece 2 will contain: Abilities, Enemies, Merchant Items,
        // Room Types, and Audio Engine
        // ------------------------------------------------------------
                // ------------------------------------------------------------
        // PIECE 2: ABILITIES, ENEMIES, MERCHANTS, ROOMS, AUDIO
        // Continue directly after Piece 1
        // ------------------------------------------------------------

        // ------------------------------------------------------------
        // SECTION 14: ABILITIES DATA
        // ------------------------------------------------------------
        
        const abilities = [
            { name: 'Icy Blast', damage: 100, cost: 20, type: 'freeze', description: 'Deals damage and freezes enemy for 1 turn', class: 'mage' },
            { name: 'Shield Bash', damage: 80, cost: 20, type: 'stun', description: 'Stun enemy for one turn', class: 'warrior' },
            { name: 'Poison Blade', damage: 40, cost: 20, type: 'poison', duration: 3, description: 'Poison damages 15 per turn for 3 turns', class: 'rogue' },
            { name: 'Chain Lightning', damage: 95, cost: 25, type: 'damage', description: 'Devastating lightning attack', class: 'mage' },
            { name: 'Arcane Missiles', damage: 105, cost: 15, type: 'aoe', description: 'Magic missiles hit all enemies', class: 'mage' },
            { name: 'Whirlwind', damage: 70, cost: 25, type: 'aoe', description: 'Spin attack hitting all enemies', class: 'warrior' },
            { name: 'Shadow Strike', damage: 40, cost: 20, type: 'sneak', description: 'Strike from shadows without enemy retaliation', class: 'rogue' },
            { name: 'Meteor Storm', damage: 145, cost: 40, type: 'aoe', description: 'Massive fire damage to all enemies', class: 'mage', minLevel: 5 },
            { name: 'Titan Smash', damage: 190, cost: 35, type: 'damage', description: 'Devastating single target attack', class: 'warrior', minLevel: 5 },
            { name: 'Assassinate', damage: 125, cost: 30, type: 'sneak', description: 'Massive stealth strike with no counter', class: 'rogue', minLevel: 5 },
            { name: 'Time Stop', damage: 0, cost: 60, type: 'timestop', description: 'Freeze all enemies for 2 turns', class: 'mage', minLevel: 6 },
            { name: 'Berserker Rage', damage: 105, cost: 30, type: 'rage', description: 'Triple attack on single target', class: 'warrior', minLevel: 6 },
            { name: 'Shadowmeld', damage: 0, cost: 25, type: 'vanish', description: 'Become invisible, next attack deals 200% damage', class: 'rogue', minLevel: 6 },
            { name: 'Divine Smite', damage: 200, cost: 60, type: 'damage', description: 'Holy damage that ignores defense', class: 'warrior', minLevel: 8 },
            { name: 'Black Hole', damage: 250, cost: 55, type: 'aoe', description: 'Void magic crushes all foes', class: 'mage', minLevel: 8 },
            { name: 'Death Mark', damage: 100, cost: 35, type: 'mark', description: 'Mark enemy for 50% more damage taken', class: 'rogue', minLevel: 8 },
            { name: 'Cosmic Devastation', damage: 300, cost: 100, type: 'aoe', description: 'Ultimate spell destroys all enemies', class: 'mage', minLevel: 10 },
            { name: 'Annihilation', damage: 400, cost: 70, type: 'damage', description: 'Total destruction single target', class: 'warrior', minLevel: 10 },
            { name: 'Soul Reaper', damage: 250, cost: 60, type: 'sneak', description: 'Harvest souls from the shadows', class: 'rogue', minLevel: 10 },
            { name: 'Ragnarok', damage: 600, cost: 120, type: 'aoe', description: 'End of all things', class: 'mage', minLevel: 20 },
            { name: 'Apocalypse Strike', damage: 800, cost: 100, type: 'damage', description: 'The final blow', class: 'warrior', minLevel: 20 },
            { name: 'Oblivion', damage: 500, cost: 90, type: 'sneak', description: 'Erase from existence', class: 'rogue', minLevel: 20 }
        ];

        // ------------------------------------------------------------
        // SECTION 15: ENEMIES DATA
        // ------------------------------------------------------------
        
        const enemies = {
            // Tier 1: Floors 1-3
            goblin: { name: 'Goblin', health: 130, damage: 18, gold: 5, exp: 25, fleeChance: 0.8 },
            skeleton: { name: 'Skeleton', health: 140, damage: 20, gold: 8, exp: 30, fleeChance: 0.7 },
            
            // Tier 2: Floors 3-5
            orc: { name: 'Orc', health: 160, damage: 35, gold: 12, exp: 50, fleeChance: 0.5 },
            wraith: { name: 'Wraith', health: 150, damage: 38, gold: 15, exp: 75, fleeChance: 0.6 },
            troll: { name: 'Troll', health: 180, damage: 50, gold: 20, exp: 65, fleeChance: 0.4, regenerate: 5 },
            
            // Tier 3: Floors 5-8
            demon: { name: 'Demon', health: 190, damage: 58, gold: 45, exp: 80, fleeChance: 0.3 },
            vampire: { name: 'Vampire', health: 200, damage: 95, gold: 40, exp: 100, fleeChance: 0.4, regenerate: 8 },
            orcChieftain: { name: 'Orc Chieftain', health: 190, damage: 72, gold: 25, exp: 65, fleeChance: 0.3 },
            ancientWraith: { name: 'Ancient Wraith', health: 190, damage: 96, gold: 30, exp: 80, fleeChance: 0.4 },
            elderTroll: { name: 'Elder Troll', health: 250, damage: 28, gold: 40, exp: 100, fleeChance: 0.2, regenerate: 10 },
            
            // Tier 4: Floors 8-10
            archDemon: { name: 'Arch Demon', health: 280, damage: 95, gold: 70, exp: 160, fleeChance: 0.2 },
            hydra: { name: 'Hydra', health: 240, damage: 130, gold: 55, exp: 125, fleeChance: 0.3, regenerate: 12 },
            phoenixGuardian: { name: 'Phoenix Guardian', health: 230, damage: 132, gold: 60, exp: 145, fleeChance: 0.3, regenerate: 15 },
            lichKing: { name: 'Lich King', health: 160, damage: 38, gold: 80, exp: 185, fleeChance: 0.1, regenerate: 10 },
            
            // Bosses: Every 10th floor
            dragon: { name: 'Dragon', health: 350, damage: 75, gold: 50, exp: 450, fleeChance: 0.1 },
            ancientDragon: { name: 'Ancient Dragon', health: 600, damage: 150, gold: 200, exp: 800, fleeChance: 0.05, regenerate: 20 },
            demonLord: { name: 'Demon Lord', health: 550, damage: 180, gold: 250, exp: 900, fleeChance: 0.05, regenerate: 25 },
            voidBeast: { name: 'Void Beast', health: 700, damage: 200, gold: 300, exp: 1000, fleeChance: 0.03, regenerate: 30 },
            cosmicHorror: { name: 'Cosmic Horror', health: 800, damage: 220, gold: 350, exp: 1200, fleeChance: 0.03, regenerate: 35 },
            titanLord: { name: 'Titan Lord', health: 1000, damage: 250, gold: 400, exp: 1500, fleeChance: 0.02, regenerate: 40 },
            harbingerOfRagnarok: { name: 'Harbinger of Ragnarok', health: 1500, damage: 300, gold: 600, exp: 2500, fleeChance: 0.01, regenerate: 50 },
            voidEmperor: { name: 'Void Emperor', health: 2000, damage: 350, gold: 800, exp: 3500, fleeChance: 0.01, regenerate: 60 },
            apocalypseTitan: { name: 'Apocalypse Titan', health: 2500, damage: 400, gold: 1000, exp: 5000, fleeChance: 0.01, regenerate: 75 }
        };

        // ------------------------------------------------------------
        // SECTION 16: MERCHANT ITEMS
        // ------------------------------------------------------------
        
        const merchantItems = [
            // Potions
            { name: 'Health Potion', type: 'potion', price: 50, healing: 50 },
            { name: 'Mana Potion', type: 'potion', price: 40, mana: 30 },
            { name: 'Greater Health Potion', type: 'potion', price: 100, healing: 150 },
            { name: 'Greater Mana Potion', type: 'potion', price: 80, mana: 80 },
            { name: 'Supreme Health Potion', type: 'potion', price: 300, healing: 300, minLevel: 10 },
            { name: 'Supreme Mana Potion', type: 'potion', price: 250, mana: 200, minLevel: 10 },
            { name: 'Ultimate Health Potion', type: 'potion', price: 800, healing: 800, minLevel: 20 },
            { name: 'Ultimate Mana Potion', type: 'potion', price: 700, mana: 500, minLevel: 20 },
            
            // Special Potions
            { name: 'Elixir of Immortality', type: 'special_potion', price: 400, effect: 'revive', description: 'Auto-revive on death with 50% health' },
            { name: 'Potion of Giant Strength', type: 'special_potion', price: 300, effect: 'strength', duration: 3, description: 'Double attack damage for 3 battles' },
            { name: 'Elixir of Clarity', type: 'special_potion', price: 350, effect: 'clarity', description: 'All spells cost 50% less mana for 3 battles' },
            
            // Special Items
            { name: "Merchant's Lucky Coin", type: 'special_item', price: 500, effect: '+50% gold from all sources', stat: 'goldBonus', value: 0.5 },
            { name: 'Crystal of Experience', type: 'special_item', price: 600, effect: '+100% experience gain', stat: 'expBonus', value: 1.0 },
            
            // Special Ring
            { name: 'Ring of Regeneration', type: 'special_ring', price: 400, effect: 'Restore 50 health per turn in combat', stat: 'regen', value: 50 },
            
            // Special Amulet
            { name: 'Amulet of the Arcane Master', type: 'special_amulet', price: 700, effect: '+50 Max Mana and +10 spell damage', manaValue: 50, damageValue: 10 }
        ];

        // ------------------------------------------------------------
        // SECTION 17: ROOM TYPES AND DESCRIPTIONS
        // ------------------------------------------------------------
        
        const roomTypes = {
            entrance: {
                descriptions: [
                    'the grand entrance hall. Torches flicker on ancient stone walls.',
                    'the entrance chamber. A faded tapestry hangs on the north wall.',
                    'the starting hall. Cobwebs drape from vaulted ceilings above.'
                ],
                hasEnemy: false
            },
            empty: {
                descriptions: [
                    'an abandoned barracks. Rusty weapons litter the floor.',
                    'a collapsed library. Torn pages scatter at your feet.',
                    'a crumbling shrine. A broken altar stands in the center.',
                    'a forgotten armory. Empty weapon racks line the walls.',
                    'a dusty workshop. Ancient tools hang from hooks.',
                    'a meditation chamber. Stone benches circle a dry fountain.',
                    'an old prison cell. Iron bars have rusted through.',
                    'a guard post. A skeleton sits slumped in a chair.'
                ],
                hasEnemy: false
            },
            treasure: {
                descriptions: [
                    'a glittering treasure vault. Gold coins reflect torchlight.',
                    'a dragon\'s hoard chamber. Piles of jewels gleam in the darkness.',
                    'a royal treasury. Ancient chests overflow with riches.',
                    'a pirate\'s cache. Stolen goods fill every corner.',
                    'a wizard\'s vault. Magical artifacts pulse with energy.'
                ],
                hasEnemy: false
            },
            enemy: {
                descriptions: [
                    'a dark chamber. You sense hostile eyes watching you.',
                    'a blood-stained arena. Old battle scars mark the floor.',
                    'a shadowy lair. Something growls in the darkness.',
                    'a monster\'s den. Bones crunch beneath your feet.',
                    'a cursed chamber. An evil presence fills the air.'
                ],
                hasEnemy: true
            },
            boss: {
                descriptions: [
                    'the throne room of darkness. A massive beast awaits on a stone throne.',
                    'the dragon\'s lair. Heat radiates from the enormous creature before you.',
                    'the demon king\'s chamber. Dark energy swirls around your foe.'
                ],
                hasEnemy: true
            },
            trap: {
                descriptions: [
                    'a trapped corridor. Pressure plates cover the floor.',
                    'a spike-filled chamber. Deadly traps line the walls.',
                    'a poison gas room. Strange vapors seep from cracks.'
                ],
                hasEnemy: false
            },
            stairs: {
                descriptions: [
                    'a spiral stairwell. Dark stone steps descend into deeper darkness.',
                    'a grand staircase. Ancient carvings decorate the descent.',
                    'a hidden passage. Secret stairs lead to the next level.'
                ],
                hasEnemy: false
            },
            fountain: {
                descriptions: [
                    'a magical fountain room. Crystal clear water bubbles from an enchanted spring.',
                    'an ancient healing shrine. A mystical fountain glows with restorative power.'
                ],
                hasEnemy: false
            },
            crypt: {
                descriptions: [
                    'a dusty crypt. Stone sarcophagi line the walls.',
                    'an ancient burial chamber. Skeletal remains rest in alcoves.',
                    'a forgotten tomb. Hieroglyphs cover every surface.'
                ],
                hasEnemy: false
            },
            merchant: {
                descriptions: [
                    'a merchant\'s tent. A hooded figure tends to various wares.',
                    'a traveling shop. Mysterious goods line makeshift shelves.'
                ],
                hasEnemy: false
            }
        };

        // ------------------------------------------------------------
        // SECTION 18: TIPS, LICENSE, AND README CONTENT
        // ------------------------------------------------------------
        
        const gameInfo = {
            tips: [
                "If equipment fails to equip, try saying hidden before the item name.",
                "There is always a hidden chest in the boss chamber. Say open chest to loot it.",
                "Say swim in the fountain to be fully healed and restored.",
                "Defending when you have a Ring of Regeneration is usually worth the effort.",
                "You can have as many Rings of Regeneration as you can afford.",
                "To swap rings you'll need to remove them first.",
                "You can't equip rings if you have 10, but the merchant can help.",
                "Bracelets now stack like rings. You can wear up to 10!",
                "Every 10 floors, your damage, defense, and abilities double.",
                "Say inspect followed by an item name to learn about it."
            ],
            license: "Echo Dungeon V11. Copyright 2025 Asa Hartz Games. This game is FREE for the community, especially the blind and visually impaired. You may play, share, and modify for personal use. You may NOT sell, monetize, or include in paid products. Contact: Acejames419@gmail.com",
            readme: "Echo Dungeon is a voice-controlled dungeon crawler designed for blind players. Tap the screen and speak commands. Say warrior, mage, or rogue to choose your class. Use cardinal directions to move: north, south, east, west. Say attack, defend, or special in combat. Say status for your stats, inventory for items, and help for commands."
        };

        // ------------------------------------------------------------
        // SECTION 19: AUDIO ENGINE - TEXT TO SPEECH
        // ------------------------------------------------------------
        
        function displayText(text) {
            textDisplay.innerHTML = text;
        }

        function speak(text, callback) {
            displayText(text);
            if (!browserSupport.speechSynthesis) {
                if (callback) setTimeout(callback, 2000);
                return;
            }
            try {
                speechSynthesis.cancel();
                setTimeout(() => {
                    const utterance = new SpeechSynthesisUtterance(text.replace(/<[^>]*>/g, ''));
                    utterance.rate = 0.9;
                    if (callback) {
                        utterance.onend = callback;
                        utterance.onerror = callback;
                    }
                    speechSynthesis.speak(utterance);
                }, 100);
            } catch (error) {
                if (callback) setTimeout(callback, 2000);
            }
        }

        function speakSequence(messages, callback) {
            if (messages.length === 0) {
                if (callback) callback();
                return;
            }
            const [first, ...rest] = messages;
            speak(first, () => {
                if (rest.length > 0) {
                    setTimeout(() => speakSequence(rest, callback), 500);
                } else if (callback) {
                    callback();
                }
            });
        }

        // ------------------------------------------------------------
        // SECTION 20: VOICE RECOGNITION ENGINE
        // ------------------------------------------------------------
        
        function startListening() {
            if (!browserSupport.speechRecognition || !browserSupport.https) {
                speak('Voice recognition requires HTTPS and a compatible browser like Chrome or Edge.');
                return;
            }
            if (game.listening) {
                stopListening();
                return;
            }
            try {
                const Recognition = window.webkitSpeechRecognition || window.SpeechRecognition;
                game.recognition = new Recognition();
                game.recognition.continuous = false;
                game.recognition.lang = 'en-US';
                
                game.recognition.onstart = () => {
                    game.listening = true;
                    micButton.classList.add('listening');
                    micButton.classList.remove('start-button');
                };
                
                game.recognition.onresult = (event) => {
                    const command = event.results[0][0].transcript.toLowerCase().trim();
                    displayText(`You said: "${command}"`);
                    stopListening();
                    setTimeout(() => processCommand(command), 500);
                };
                
                game.recognition.onerror = (event) => {
                    stopListening();
                    if (event.error !== 'no-speech' && event.error !== 'aborted') {
                        speak('Voice error. Try again.');
                    }
                };
                
                game.recognition.onend = () => stopListening();
                game.recognition.start();
            } catch (error) {
                speak('Failed to start voice recognition.');
                stopListening();
            }
        }

        function stopListening() {
            game.listening = false;
            micButton.classList.remove('listening');
            if (game.recognition) {
                try {
                    game.recognition.stop();
                } catch (e) {}
                game.recognition = null;
            }
        }

        // ------------------------------------------------------------
        // SECTION 21: FLOOR SCALING SYSTEM
        // Every 10 floors: damage, defense, abilities, mana costs double
        // ------------------------------------------------------------
        
        function getFloorMultiplier() {
            const floorTier = Math.floor((game.dungeon.currentLevel - 1) / 10);
            return Math.pow(2, floorTier);
        }

        function applyFloorScaling() {
            const multiplier = getFloorMultiplier();
            game.player.damageMultiplier = multiplier;
            game.player.defenseMultiplier = multiplier;
            game.player.manaMultiplier = multiplier;
        }

        function getFloorMilestoneMessage(floor) {
            const messages = {
                10: "As you descend past the tenth floor, power surges through you. You feel stronger, your muscles tighter. Your spells crackle with twice the energy. The dungeon grows deadlier, but so do you.",
                20: "The twentieth floor marks a transformation. Your attacks devastate, your mind expands. You are becoming something beyond mortal. All your abilities have doubled in power.",
                30: "Thirty floors deep, you are a force of nature. Warriors flee at your approach. Your damage, defense, and magical power have quadrupled from where you began.",
                40: "At forty floors, legends speak of you. Your power is eight times what it once was. The darkness itself seems to bow before you.",
                50: "Fifty floors. You have transcended humanity. Sixteen times your original power flows through you. You are become death, destroyer of dungeons."
            };
            return messages[floor] || null;
        }

        // ------------------------------------------------------------
        // SECTION 22: DEFENSE RECALCULATION (Complete)
        // ------------------------------------------------------------
        
        function recalculateDefense() {
            let totalDefense = 0;
            
            // Armor defense
            if (game.player.armor) {
                const armorData = armors.find(a => a.name === game.player.armor);
                if (armorData && armorData.defense) {
                    totalDefense += armorData.defense;
                }
            }
            
            // Shield defense
            if (game.player.shield) {
                const shieldData = shields.find(s => s.name === game.player.shield);
                if (shieldData && shieldData.defense) {
                    totalDefense += shieldData.defense;
                }
            }
            
            // Helmet defense
            if (game.player.helmet) {
                const helmetData = helmets.find(h => h.name === game.player.helmet);
                if (helmetData && helmetData.defense) {
                    totalDefense += helmetData.defense;
                }
            }
            
            // Boots defense
            if (game.player.boots) {
                const bootsData = boots.find(b => b.name === game.player.boots);
                if (bootsData && bootsData.defense) {
                    totalDefense += bootsData.defense;
                }
            }
            
            // Gloves defense (if any)
            if (game.player.gloves) {
                const glovesData = gloves.find(g => g.name === game.player.gloves);
                if (glovesData && glovesData.defense) {
                    totalDefense += glovesData.defense;
                }
            }
            
            // Apply floor multiplier
            game.player.defense = totalDefense * game.player.defenseMultiplier;
        }

        // ------------------------------------------------------------
        // SECTION 23: TOTAL ATTACK CALCULATION
        // ------------------------------------------------------------
        
        function calculateTotalAttack() {
            let totalAttack = game.player.baseAttack;
            
            // Weapon attack
            if (game.player.weapon) {
                const weaponData = weapons.find(w => w.name === game.player.weapon);
                if (weaponData) {
                    totalAttack += weaponData.attack;
                }
            }
            
            // Gloves attack bonus
            if (game.player.gloves) {
                const glovesData = gloves.find(g => g.name === game.player.gloves);
                if (glovesData && glovesData.attack) {
                    totalAttack += glovesData.attack;
                }
            }
            
            // Ring attack bonuses
            game.player.equippedRings.forEach(ringName => {
                const ringData = rings.find(r => r.name === ringName);
                if (ringData && ringData.stat === 'attack') {
                    totalAttack += ringData.value;
                }
            });
            
            // Bracelet attack bonuses (NEW: stacking like rings)
            game.player.equippedBracelets.forEach(braceletName => {
                const braceletData = bracelets.find(b => b.name === braceletName);
                if (braceletData && braceletData.attack) {
                    totalAttack += braceletData.attack;
                }
            });
            
            // Amulet attack bonus
            if (game.player.equippedAmulet) {
                const amuletData = amulets.find(a => a.name === game.player.equippedAmulet);
                if (amuletData && amuletData.stat === 'attack') {
                    totalAttack += amuletData.value;
                }
            }
            
            // Apply floor multiplier
            return totalAttack * game.player.damageMultiplier;
        }

        // ------------------------------------------------------------
        // END OF PIECE 2
        // Piece 3 will contain: Bracelet System Functions,
        // Ring System, Junk Bag System, Item Inspection
        // ------------------------------------------------------------
                // ------------------------------------------------------------
        // PIECE 3: BRACELET SYSTEM, RING SYSTEM, JUNK BAG, INSPECTION
        // Continue directly after Piece 2
        // ------------------------------------------------------------

        // ------------------------------------------------------------
        // SECTION 24: BRACELET SYSTEM (Ring-Style, Up to 10)
        // ------------------------------------------------------------
        
        function equipBracelet(command) {
            // Find which bracelet the player wants to equip
            let braceletName = null;
            
            for (let bracelet of bracelets) {
                if (command.includes(bracelet.name.toLowerCase())) {
                    braceletName = bracelet.name;
                    break;
                }
            }
            
            // Also check merchant bracelets
            if (!braceletName) {
                const merchantBracelets = merchantItems.filter(i => i.type === 'bracelet');
                for (let bracelet of merchantBracelets) {
                    if (command.includes(bracelet.name.toLowerCase())) {
                        braceletName = bracelet.name;
                        break;
                    }
                }
            }
            
            // If no specific bracelet named, list available
            if (!braceletName) {
                const availableBracelets = game.player.inventory.filter(item =>
                    bracelets.some(b => b.name === item)
                );
                if (availableBracelets.length > 0) {
                    speak(`You have: ${availableBracelets.join(', ')}. Say which one to equip.`);
                } else {
                    speak('You have no bracelets. Find them in treasure chests or buy from merchants.');
                }
                return;
            }
            
            // Check if player has this bracelet in inventory
            const braceletIndex = game.player.inventory.findIndex(item => item === braceletName);
            if (braceletIndex === -1) {
                speak(`You do not have a ${braceletName}.`);
                return;
            }
            
            // Check if already wearing 10 bracelets
            if (game.player.equippedBracelets.length >= 10) {
                speak('You already have 10 bracelets equipped. Say remove bracelet first.');
                return;
            }
            
            // Check if already wearing 2 of the same bracelet (stack limit)
            const equippedCount = game.player.equippedBracelets.filter(b => b === braceletName).length;
            if (equippedCount >= 2) {
                speak(`You already have 2 ${braceletName} equipped. You can only stack 2 of the same bracelet.`);
                return;
            }
            
            // Get bracelet data
            const braceletData = bracelets.find(b => b.name === braceletName);
            if (!braceletData) {
                speak('Error: Bracelet data not found.');
                return;
            }
            
            // Remove from inventory and add to equipped
            game.player.inventory.splice(braceletIndex, 1);
            game.player.equippedBracelets.push(braceletName);
            
            // Apply stat bonuses
            let bonusMessage = '';
            if (braceletData.attack) {
                bonusMessage += `Attack increased by ${braceletData.attack}. `;
            }
            if (braceletData.mana) {
                game.player.maxMana += braceletData.mana;
                game.player.mana += braceletData.mana;
                bonusMessage += `Max mana increased by ${braceletData.mana}. `;
            }
            
            speak(`You equip the ${braceletName}. ${bonusMessage}You have ${game.player.equippedBracelets.length} bracelets equipped.`);
        }

        function removeBracelet(command) {
            if (game.player.equippedBracelets.length === 0) {
                speak('You have no bracelets equipped.');
                return;
            }
            
            // Find which bracelet to remove
            let braceletName = null;
            
            for (let bracelet of bracelets) {
                if (command.includes(bracelet.name.toLowerCase())) {
                    braceletName = bracelet.name;
                    break;
                }
            }
            
            // If no specific bracelet named, list equipped
            if (!braceletName) {
                const equippedCounts = {};
                game.player.equippedBracelets.forEach(b => {
                    equippedCounts[b] = (equippedCounts[b] || 0) + 1;
                });
                const equippedList = Object.entries(equippedCounts).map(([bracelet, count]) =>
                    count > 1 ? `${bracelet} x${count}` : bracelet
                );
                speak(`Equipped bracelets: ${equippedList.join(', ')}. Say which one to remove.`);
                return;
            }
            
            // Check if this bracelet is equipped
            const braceletIndex = game.player.equippedBracelets.findIndex(b => b === braceletName);
            if (braceletIndex === -1) {
                speak(`You do not have ${braceletName} equipped.`);
                return;
            }
            
            // Get bracelet data
            const braceletData = bracelets.find(b => b.name === braceletName);
            
            // Remove from equipped and add to inventory
            game.player.equippedBracelets.splice(braceletIndex, 1);
            game.player.inventory.push(braceletName);
            
            // Remove stat bonuses
            let bonusMessage = '';
            if (braceletData && braceletData.mana) {
                game.player.maxMana -= braceletData.mana;
                game.player.mana = Math.min(game.player.mana, game.player.maxMana);
                bonusMessage += `Max mana decreased by ${braceletData.mana}. `;
            }
            
            speak(`You remove the ${braceletName}. ${bonusMessage}You have ${game.player.equippedBracelets.length} bracelets equipped.`);
        }

        // ------------------------------------------------------------
        // SECTION 25: RING SYSTEM (Preserved from V10.5)
        // ------------------------------------------------------------
        
        function equipRing(command) {
            // Find which ring the player wants to equip
            let ringName = null;
            
            for (let ring of rings) {
                if (command.includes(ring.name.toLowerCase())) {
                    ringName = ring.name;
                    break;
                }
            }
            
            // Check for Ring of Regeneration from merchant
            if (command.includes('regeneration')) {
                ringName = 'Ring of Regeneration';
            }
            
            // If no specific ring named, list available
            if (!ringName) {
                const availableRings = game.player.inventory.filter(item =>
                    rings.some(r => r.name === item) || item === 'Ring of Regeneration'
                );
                if (availableRings.length > 0) {
                    speak(`You have: ${availableRings.join(', ')}. Say which one to equip.`);
                } else {
                    speak('You have no rings. Find them in treasure chests or by searching rooms.');
                }
                return;
            }
            
            // Check if player has this ring in inventory
            const ringIndex = game.player.inventory.findIndex(item => item === ringName);
            if (ringIndex === -1) {
                speak(`You do not have a ${ringName}.`);
                return;
            }
            
            // Check if already wearing 10 rings
            if (game.player.equippedRings.length >= 10) {
                speak('You already have 10 rings equipped. Say remove ring first.');
                return;
            }
            
            // Check if already wearing 2 of the same ring (stack limit)
            const equippedCount = game.player.equippedRings.filter(r => r === ringName).length;
            if (equippedCount >= 2) {
                speak(`You already have 2 ${ringName} equipped. You can only stack 2 of the same ring.`);
                return;
            }
            
            // Get ring data
            const ringData = rings.find(r => r.name === ringName);
            
            // Remove from inventory and add to equipped
            game.player.inventory.splice(ringIndex, 1);
            game.player.equippedRings.push(ringName);
            
            // Apply stat bonuses
            if (ringName === 'Ring of Regeneration') {
                speak(`You equip the ${ringName}. You will restore 50 health per turn in combat! You have ${game.player.equippedRings.length} rings equipped.`);
            } else if (ringData && ringData.stat === 'maxHealth') {
                game.player.maxHealth += ringData.value;
                game.player.health += ringData.value;
                speak(`You equip the ${ringName}. Your max health increased by ${ringData.value}! You have ${game.player.equippedRings.length} rings equipped.`);
            } else if (ringData && ringData.stat === 'maxMana') {
                game.player.maxMana += ringData.value;
                game.player.mana += ringData.value;
                speak(`You equip the ${ringName}. Your max mana increased by ${ringData.value}! You have ${game.player.equippedRings.length} rings equipped.`);
            } else if (ringData && ringData.stat === 'attack') {
                speak(`You equip the ${ringName}. Your attacks are now stronger! You have ${game.player.equippedRings.length} rings equipped.`);
            } else {
                speak(`You equip the ${ringName}. You have ${game.player.equippedRings.length} rings equipped.`);
            }
        }

        function removeRing(command) {
            if (game.player.equippedRings.length === 0) {
                speak('You have no rings equipped.');
                return;
            }
            
            // Find which ring to remove
            let ringName = null;
            
            for (let ring of rings) {
                if (command.includes(ring.name.toLowerCase())) {
                    ringName = ring.name;
                    break;
                }
            }
            
            if (command.includes('regeneration')) {
                ringName = 'Ring of Regeneration';
            }
            
            // If no specific ring named, list equipped
            if (!ringName) {
                const equippedCounts = {};
                game.player.equippedRings.forEach(ring => {
                    equippedCounts[ring] = (equippedCounts[ring] || 0) + 1;
                });
                const equippedList = Object.entries(equippedCounts).map(([ring, count]) =>
                    count > 1 ? `${ring} x${count}` : ring
                );
                speak(`Equipped rings: ${equippedList.join(', ')}. Say which one to remove.`);
                return;
            }
            
            // Check if this ring is equipped
            const ringIndex = game.player.equippedRings.findIndex(r => r === ringName);
            if (ringIndex === -1) {
                speak(`You do not have ${ringName} equipped.`);
                return;
            }
            
            // Get ring data
            const ringData = rings.find(r => r.name === ringName);
            
            // Remove from equipped and add to inventory
            game.player.equippedRings.splice(ringIndex, 1);
            game.player.inventory.push(ringName);
            
            // Remove stat bonuses
            if (ringName === 'Ring of Regeneration') {
                speak(`You remove the ${ringName}. You have ${game.player.equippedRings.length} rings equipped.`);
            } else if (ringData && ringData.stat === 'maxHealth') {
                game.player.maxHealth -= ringData.value;
                game.player.health = Math.min(game.player.health, game.player.maxHealth);
                speak(`You remove the ${ringName}. Max health decreased by ${ringData.value}. You have ${game.player.equippedRings.length} rings equipped.`);
            } else if (ringData && ringData.stat === 'maxMana') {
                game.player.maxMana -= ringData.value;
                game.player.mana = Math.min(game.player.mana, game.player.maxMana);
                speak(`You remove the ${ringName}. Max mana decreased by ${ringData.value}. You have ${game.player.equippedRings.length} rings equipped.`);
            } else if (ringData && ringData.stat === 'attack') {
                speak(`You remove the ${ringName}. You have ${game.player.equippedRings.length} rings equipped.`);
            } else {
                speak(`You remove the ${ringName}. You have ${game.player.equippedRings.length} rings equipped.`);
            }
        }

        // ------------------------------------------------------------
        // SECTION 26: AMULET SYSTEM
        // ------------------------------------------------------------
        
        function equipAmulet(command) {
            let amuletName = null;
            
            for (let amulet of amulets) {
                if (command.includes(amulet.name.toLowerCase())) {
                    amuletName = amulet.name;
                    break;
                }
            }
            
            // Check merchant special amulet
            if (command.includes('arcane master')) {
                amuletName = 'Amulet of the Arcane Master';
            }
            
            if (!amuletName) {
                const availableAmulets = game.player.inventory.filter(item =>
                    amulets.some(a => a.name === item) || item === 'Amulet of the Arcane Master'
                );
                if (availableAmulets.length > 0) {
                    speak(`You have: ${availableAmulets.join(', ')}. Say which one to equip.`);
                } else {
                    speak('You have no amulets. Find them in treasure chests or by searching rooms.');
                }
                return;
            }
            
            const amuletIndex = game.player.inventory.findIndex(item => item === amuletName);
            if (amuletIndex === -1) {
                speak(`You do not have the ${amuletName}.`);
                return;
            }
            
            // Unequip current amulet if wearing one
            if (game.player.equippedAmulet) {
                const oldAmulet = game.player.equippedAmulet;
                const oldAmuletData = amulets.find(a => a.name === oldAmulet);
                
                // Remove old amulet stats
                if (oldAmuletData) {
                    if (oldAmuletData.stat === 'maxHealth') {
                        game.player.maxHealth -= oldAmuletData.value;
                        game.player.health = Math.min(game.player.health, game.player.maxHealth);
                    } else if (oldAmuletData.stat === 'maxMana') {
                        game.player.maxMana -= oldAmuletData.value;
                        game.player.mana = Math.min(game.player.mana, game.player.maxMana);
                    }
                }
                
                // Check for special merchant amulet
                if (oldAmulet === 'Amulet of the Arcane Master') {
                    game.player.maxMana -= 50;
                    game.player.mana = Math.min(game.player.mana, game.player.maxMana);
                }
                
                game.player.inventory.push(oldAmulet);
            }
            
            // Equip new amulet
            game.player.inventory.splice(amuletIndex, 1);
            game.player.equippedAmulet = amuletName;
            
            const amuletData = amulets.find(a => a.name === amuletName);
            
            if (amuletName === 'Amulet of the Arcane Master') {
                game.player.maxMana += 50;
                game.player.mana += 50;
                speak(`You equip the ${amuletName}. Max mana increased by 50 and spell damage increased by 10!`);
            } else if (amuletData && amuletData.stat === 'maxHealth') {
                game.player.maxHealth += amuletData.value;
                game.player.health += amuletData.value;
                speak(`You equip the ${amuletName}. Your max health increased by ${amuletData.value}!`);
            } else if (amuletData && amuletData.stat === 'maxMana') {
                game.player.maxMana += amuletData.value;
                game.player.mana += amuletData.value;
                speak(`You equip the ${amuletName}. Your max mana increased by ${amuletData.value}!`);
            } else if (amuletData && amuletData.stat === 'expGain') {
                speak(`You equip the ${amuletName}. You now gain 20% more experience!`);
            } else if (amuletData && amuletData.stat === 'attack') {
                speak(`You equip the ${amuletName}. Your attack power increases by ${amuletData.value}!`);
            } else {
                speak(`You equip the ${amuletName}.`);
            }
        }

        // ------------------------------------------------------------
        // SECTION 27: JUNK BAG SYSTEM (Fixed)
        // ------------------------------------------------------------
        
        function addToJunk(command) {
            // Find sellable items in inventory
            const sellableItems = game.player.inventory.filter(item => {
                return weapons.some(w => w.name === item) ||
                       armors.some(a => a.name === item) ||
                       shields.some(s => s.name === item) ||
                       helmets.some(h => h.name === item) ||
                       gloves.some(g => g.name === item) ||
                       boots.some(b => b.name === item) ||
                       bracelets.some(br => br.name === item) ||
                       rings.some(r => r.name === item) ||
                       amulets.some(a => a.name === item) ||
                       treasures.some(t => t.name === item);
            });
            
            if (sellableItems.length === 0) {
                speak('You have no equipment or treasures to add to junk bag.');
                return;
            }
            
            // Find item mentioned in command
            let itemToAdd = null;
            for (let item of sellableItems) {
                if (command.includes(item.toLowerCase())) {
                    itemToAdd = item;
                    break;
                }
            }
            
            if (!itemToAdd) {
                speak(`You can add to junk: ${sellableItems.slice(0, 5).join(', ')}${sellableItems.length > 5 ? ' and more' : ''}. Say which item.`);
                return;
            }
            
            // Check if already in junk bag
            if (game.player.junkBag.includes(itemToAdd)) {
                speak(`${itemToAdd} is already in your junk bag.`);
                return;
            }
            
            // Add to junk bag (item stays in inventory until sold)
            game.player.junkBag.push(itemToAdd);
            speak(`Added ${itemToAdd} to junk bag. Say sell junk at a merchant to sell all junk.`);
        }

        function removeFromJunk(command) {
            if (game.player.junkBag.length === 0) {
                speak('Your junk bag is empty.');
                return;
            }
            
            let itemToRemove = null;
            for (let item of game.player.junkBag) {
                if (command.includes(item.toLowerCase())) {
                    itemToRemove = item;
                    break;
                }
            }
            
            if (!itemToRemove) {
                speak(`Junk bag contains: ${game.player.junkBag.join(', ')}. Say which to remove.`);
                return;
            }
            
            const index = game.player.junkBag.indexOf(itemToRemove);
            game.player.junkBag.splice(index, 1);
            speak(`Removed ${itemToRemove} from junk bag.`);
        }

        function sellAllJunk() {
            if (!game.merchantOpen) {
                speak('You need to be at a merchant to sell junk.');
                return;
            }
            
            if (game.player.junkBag.length === 0) {
                speak('Your junk bag is empty. Say add to junk followed by item names to mark items for sale.');
                return;
            }
            
            let totalGold = 0;
            const soldItems = [];
            
            for (let itemName of game.player.junkBag) {
                const itemIndex = game.player.inventory.indexOf(itemName);
                if (itemIndex === -1) continue;
                
                let itemValue = 0;
                
                // Check all equipment categories for value
                const weaponData = weapons.find(w => w.name === itemName);
                const armorData = armors.find(a => a.name === itemName);
                const shieldData = shields.find(s => s.name === itemName);
                const helmetData = helmets.find(h => h.name === itemName);
                const glovesData = gloves.find(g => g.name === itemName);
                const bootsData = boots.find(b => b.name === itemName);
                const braceletData = bracelets.find(br => br.name === itemName);
                const ringData = rings.find(r => r.name === itemName);
                const amuletData = amulets.find(a => a.name === itemName);
                const treasureData = treasures.find(t => t.name === itemName);
                
                if (weaponData) itemValue = Math.floor(weaponData.value * 0.6);
                else if (armorData) itemValue = Math.floor(armorData.value * 0.6);
                else if (shieldData) itemValue = Math.floor(shieldData.value * 0.6);
                else if (helmetData) itemValue = Math.floor(helmetData.value * 0.6);
                else if (glovesData) itemValue = Math.floor(glovesData.value * 0.6);
                else if (bootsData) itemValue = Math.floor(bootsData.value * 0.6);
                else if (braceletData) itemValue = Math.floor(braceletData.value * 0.6);
                else if (ringData) itemValue = 50; // Rings have no value property
                else if (amuletData) itemValue = 50; // Amulets have no value property
                else if (treasureData) itemValue = treasureData.value;
                else itemValue = 20;
                
                game.player.inventory.splice(itemIndex, 1);
                totalGold += itemValue;
                soldItems.push(itemName);
            }
            
            game.player.gold += totalGold;
            game.player.junkBag = [];
            
            speak(`Sold ${soldItems.length} items for ${totalGold} gold! Total gold: ${game.player.gold}.`);
        }

        function viewJunk() {
            if (game.player.junkBag.length === 0) {
                speak('Your junk bag is empty.');
            } else {
                speak(`Junk bag contains: ${game.player.junkBag.join(', ')}. ${game.player.junkBag.length} items ready to sell.`);
            }
        }

        function clearJunk() {
            if (game.player.junkBag.length === 0) {
                speak('Your junk bag is already empty.');
            } else {
                game.player.junkBag = [];
                speak('Junk bag cleared. All items remain in inventory.');
            }
        }

        // ------------------------------------------------------------
        // SECTION 28: ITEM INSPECTION SYSTEM
        // ------------------------------------------------------------
        
        function inspectItem(command) {
            // Find item name in command
            let itemName = null;
            let itemData = null;
            let itemType = '';
            
            // Check weapons
            for (let weapon of weapons) {
                if (command.includes(weapon.name.toLowerCase())) {
                    itemName = weapon.name;
                    itemData = weapon;
                    itemType = 'weapon';
                    break;
                }
            }
            
            // Check armors
            if (!itemName) {
                for (let armor of armors) {
                    if (command.includes(armor.name.toLowerCase())) {
                        itemName = armor.name;
                        itemData = armor;
                        itemType = 'armor';
                        break;
                    }
                }
            }
            
            // Check shields
            if (!itemName) {
                for (let shield of shields) {
                    if (command.includes(shield.name.toLowerCase())) {
                        itemName = shield.name;
                        itemData = shield;
                        itemType = 'shield';
                        break;
                    }
                }
            }
            
            // Check helmets
            if (!itemName) {
                for (let helmet of helmets) {
                    if (command.includes(helmet.name.toLowerCase())) {
                        itemName = helmet.name;
                        itemData = helmet;
                        itemType = 'helmet';
                        break;
                    }
                }
            }
            
            // Check gloves
            if (!itemName) {
                for (let glove of gloves) {
                    if (command.includes(glove.name.toLowerCase())) {
                        itemName = glove.name;
                        itemData = glove;
                        itemType = 'gloves';
                        break;
                    }
                }
            }
            
            // Check boots
            if (!itemName) {
                for (let boot of boots) {
                    if (command.includes(boot.name.toLowerCase())) {
                        itemName = boot.name;
                        itemData = boot;
                        itemType = 'boots';
                        break;
                    }
                }
            }
            
            // Check bracelets
            if (!itemName) {
                for (let bracelet of bracelets) {
                    if (command.includes(bracelet.name.toLowerCase())) {
                        itemName = bracelet.name;
                        itemData = bracelet;
                        itemType = 'bracelet';
                        break;
                    }
                }
            }
            
            // Check rings
            if (!itemName) {
                for (let ring of rings) {
                    if (command.includes(ring.name.toLowerCase())) {
                        itemName = ring.name;
                        itemData = ring;
                        itemType = 'ring';
                        break;
                    }
                }
            }
            
            // Check amulets
            if (!itemName) {
                for (let amulet of amulets) {
                    if (command.includes(amulet.name.toLowerCase())) {
                        itemName = amulet.name;
                        itemData = amulet;
                        itemType = 'amulet';
                        break;
                    }
                }
            }
            
            if (!itemName || !itemData) {
                speak('Item not found. Say inspect followed by the item name.');
                return;
            }
            
            // Build inspection message
            let messages = [`Inspecting ${itemName}. Type: ${itemType}.`];
            
            if (itemData.attack) {
                messages.push(`Attack power: ${itemData.attack}.`);
            }
            if (itemData.defense) {
                messages.push(`Defense: ${itemData.defense}.`);
            }
            if (itemData.mana) {
                messages.push(`Mana bonus: ${itemData.mana}.`);
            }
            if (itemData.health) {
                messages.push(`Health bonus: ${itemData.health}.`);
            }
            if (itemData.effect) {
                messages.push(`Effect: ${itemData.effect}.`);
            }
            if (itemData.value) {
                messages.push(`Value: ${itemData.value} gold. Sells for ${Math.floor(itemData.value * 0.6)} gold.`);
            }
            if (itemData.class) {
                messages.push(`Class requirement: ${itemData.class}.`);
            }
            if (itemData.minLevel) {
                messages.push(`Minimum dungeon level: ${itemData.minLevel}.`);
            }
            
            speakSequence(messages);
        }

        // ------------------------------------------------------------
        // END OF PIECE 3
        // Piece 4 will contain: Save/Load System with Named Characters,
        // Class Selection, Game Initialization
        // ------------------------------------------------------------
                // ------------------------------------------------------------
        // PIECE 4: SAVE/LOAD SYSTEM, CLASS SELECTION, INITIALIZATION
        // Continue directly after Piece 3
        // ------------------------------------------------------------

        // ------------------------------------------------------------
        // SECTION 29: NAMED CHARACTER SAVE SYSTEM
        // Players speak a character name to save/load
        // Sequential tracking is silent (00001, 00002, etc.)
        // ------------------------------------------------------------
        
        function getNextSaveNumber() {
            // Get the next sequential save number
            let counter = parseInt(localStorage.getItem('echoDungeon_saveCounter') || '0');
            counter++;
            localStorage.setItem('echoDungeon_saveCounter', counter.toString());
            return counter.toString().padStart(5, '0');
        }

        function getAllSavedCharacters() {
            const characters = {};
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith('echoDungeon_char_')) {
                    const charName = key.replace('echoDungeon_char_', '');
                    try {
                        const data = JSON.parse(localStorage.getItem(key));
                        characters[charName] = data;
                    } catch (e) {
                        // Skip corrupted saves
                    }
                }
            }
            return characters;
        }

        function saveGame(command) {
            // Extract character name from command
            let characterName = '';
            
            // Check if player already has a name
            if (game.player.name) {
                characterName = game.player.name;
            } else {
                // Try to extract name from command like "save game as Aldric"
                const nameMatch = command.match(/save\s+(?:game\s+)?(?:as\s+)?(.+)/i);
                if (nameMatch && nameMatch[1]) {
                    characterName = nameMatch[1].trim();
                }
            }
            
            if (!characterName) {
                speak('Please say save game followed by your character name. For example, save game as Aldric.');
                return;
            }
            
            // Clean up character name
            characterName = characterName.replace(/[^a-zA-Z0-9\s]/g, '').trim();
            if (characterName.length < 2) {
                speak('Character name must be at least 2 characters. Please try again.');
                return;
            }
            
            // Set the player name
            game.player.name = characterName;
            
            // Get silent sequential number
            const saveNumber = getNextSaveNumber();
            
            // Prepare save data
            const saveData = {
                version: 'V11',
                saveNumber: saveNumber,
                timestamp: Date.now(),
                player: {
                    name: game.player.name,
                    class: game.player.class,
                    level: game.player.level,
                    experience: game.player.experience,
                    experienceToNext: game.player.experienceToNext,
                    health: game.player.health,
                    maxHealth: game.player.maxHealth,
                    mana: game.player.mana,
                    maxMana: game.player.maxMana,
                    gold: game.player.gold,
                    inventory: [...game.player.inventory],
                    equippedRings: [...game.player.equippedRings],
                    equippedBracelets: [...game.player.equippedBracelets],
                    learnedAbilities: [...game.player.learnedAbilities],
                    equippedAmulet: game.player.equippedAmulet,
                    position: { ...game.player.position },
                    baseAttack: game.player.baseAttack,
                    defense: game.player.defense,
                    weapon: game.player.weapon,
                    armor: game.player.armor,
                    shield: game.player.shield,
                    helmet: game.player.helmet,
                    gloves: game.player.gloves,
                    boots: game.player.boots,
                    specialItems: [...game.player.specialItems],
                    activeEffects: [...game.player.activeEffects],
                    junkBag: [...game.player.junkBag],
                    damageMultiplier: game.player.damageMultiplier,
                    defenseMultiplier: game.player.defenseMultiplier,
                    manaMultiplier: game.player.manaMultiplier
                },
                dungeon: {
                    grid: game.dungeon.grid,
                    size: game.dungeon.size,
                    currentLevel: game.dungeon.currentLevel,
                    hasSecretRoom: game.dungeon.hasSecretRoom
                }
            };
            
            // Save to localStorage with character name as key
            const saveKey = `echoDungeon_char_${characterName.toLowerCase()}`;
            
            try {
                localStorage.setItem(saveKey, JSON.stringify(saveData));
                speak(`Game saved for ${characterName}. Level ${game.player.level} ${classes[game.player.class].name} on dungeon level ${game.dungeon.currentLevel}. To continue later, just say the name ${characterName}.`);
            } catch (e) {
                speak('Error saving game. Storage may be full.');
            }
        }

        function loadGame(command) {
            // Extract character name from command
            let characterName = '';
            
            // Try various patterns
            const patterns = [
                /load\s+(?:game\s+)?(.+)/i,
                /play\s+as\s+(.+)/i,
                /continue\s+(?:as\s+)?(.+)/i,
                /^([a-zA-Z]+)$/i  // Just the name
            ];
            
            for (let pattern of patterns) {
                const match = command.match(pattern);
                if (match && match[1]) {
                    characterName = match[1].trim().toLowerCase();
                    break;
                }
            }
            
            if (!characterName) {
                // List available characters
                const savedChars = getAllSavedCharacters();
                const charNames = Object.keys(savedChars);
                
                if (charNames.length === 0) {
                    speak('No saved characters found. Start a new game by choosing warrior, mage, or rogue.');
                } else {
                    speak(`Available characters: ${charNames.join(', ')}. Say the character name to load.`);
                }
                return;
            }
            
            // Clean up character name
            characterName = characterName.replace(/[^a-zA-Z0-9\s]/g, '').trim().toLowerCase();
            
            // Try to load
            const saveKey = `echoDungeon_char_${characterName}`;
            const saveData = localStorage.getItem(saveKey);
            
            if (!saveData) {
                speak(`No saved game found for ${characterName}. Say the character name exactly as you saved it, or start a new game.`);
                return;
            }
            
            try {
                const data = JSON.parse(saveData);
                
                // Restore player data
                game.player.name = data.player.name;
                game.player.class = data.player.class;
                game.player.level = data.player.level;
                game.player.experience = data.player.experience;
                game.player.experienceToNext = data.player.experienceToNext;
                game.player.health = data.player.health;
                game.player.maxHealth = data.player.maxHealth;
                game.player.mana = data.player.mana;
                game.player.maxMana = data.player.maxMana;
                game.player.gold = data.player.gold;
                game.player.inventory = data.player.inventory || [];
                game.player.equippedRings = data.player.equippedRings || [];
                game.player.equippedBracelets = data.player.equippedBracelets || [];
                game.player.learnedAbilities = data.player.learnedAbilities || [];
                game.player.equippedAmulet = data.player.equippedAmulet || '';
                game.player.position = data.player.position;
                game.player.baseAttack = data.player.baseAttack;
                game.player.defense = data.player.defense;
                game.player.weapon = data.player.weapon;
                game.player.armor = data.player.armor;
                game.player.shield = data.player.shield || '';
                game.player.helmet = data.player.helmet || '';
                game.player.gloves = data.player.gloves || '';
                game.player.boots = data.player.boots || '';
                game.player.specialItems = data.player.specialItems || [];
                game.player.activeEffects = data.player.activeEffects || [];
                game.player.junkBag = data.player.junkBag || [];
                game.player.damageMultiplier = data.player.damageMultiplier || 1;
                game.player.defenseMultiplier = data.player.defenseMultiplier || 1;
                game.player.manaMultiplier = data.player.manaMultiplier || 1;
                
                // Restore dungeon data
                game.dungeon.grid = data.dungeon.grid;
                game.dungeon.size = data.dungeon.size;
                game.dungeon.currentLevel = data.dungeon.currentLevel;
                game.dungeon.hasSecretRoom = data.dungeon.hasSecretRoom || false;
                
                // Set current room
                const key = `${game.player.position.x},${game.player.position.y}`;
                game.currentRoom = game.dungeon.grid[key];
                
                // Update game state
                game.initialized = true;
                game.started = true;
                game.needsClass = false;
                game.phase = 'exploration';
                micButton.classList.remove('start-button');
                
                speak(`Welcome back, ${data.player.name}! Level ${game.player.level} ${classes[game.player.class].name} on dungeon level ${game.dungeon.currentLevel}. Health ${game.player.health}, Mana ${game.player.mana}, Gold ${game.player.gold}.`, () => {
                    setTimeout(() => describeRoom(), 1000);
                });
                
            } catch (e) {
                speak('Error loading game. Save file may be corrupted.');
            }
        }

        function deleteCharacter(command) {
            let characterName = '';
            const match = command.match(/delete\s+(?:character\s+)?(.+)/i);
            if (match && match[1]) {
                characterName = match[1].trim().toLowerCase();
            }
            
            if (!characterName) {
                speak('Say delete character followed by the character name.');
                return;
            }
            
            const saveKey = `echoDungeon_char_${characterName}`;
            if (localStorage.getItem(saveKey)) {
                localStorage.removeItem(saveKey);
                speak(`Character ${characterName} has been deleted.`);
            } else {
                speak(`No character named ${characterName} found.`);
            }
        }

        function listCharacters() {
            const savedChars = getAllSavedCharacters();
            const charNames = Object.keys(savedChars);
            
            if (charNames.length === 0) {
                speak('No saved characters. Start a new game by choosing warrior, mage, or rogue.');
                return;
            }
            
            let messages = ['Your saved characters:'];
            for (let name of charNames) {
                const data = savedChars[name];
                messages.push(`${data.player.name}. Level ${data.player.level} ${classes[data.player.class].name}. Dungeon level ${data.dungeon.currentLevel}.`);
            }
            messages.push('Say a character name to continue their adventure.');
            speakSequence(messages);
        }

        // ------------------------------------------------------------
        // SECTION 30: CLASS SELECTION
        // ------------------------------------------------------------
        
        function selectClass(className) {
            const classData = classes[className];
            
            game.player.class = className;
            game.player.health = classData.health;
            game.player.maxHealth = classData.maxHealth;
            game.player.mana = classData.mana;
            game.player.maxMana = classData.maxMana;
            game.player.gold = classData.gold;
            game.player.inventory = [...classData.items];
            game.player.equippedRings = [];
            game.player.equippedBracelets = [];
            game.player.learnedAbilities = [];
            game.player.equippedAmulet = '';
            game.player.junkBag = [];
            game.player.damageMultiplier = 1;
            game.player.defenseMultiplier = 1;
            game.player.manaMultiplier = 1;
            
            // Find and equip starting weapon
            game.player.weapon = classData.items.find(item => weapons.some(w => w.name === item)) || '';
            
            // Find and equip starting armor
            game.player.armor = classData.items.find(item => armors.some(a => a.name === item)) || '';
            
            // Find and equip starting shield
            game.player.shield = classData.items.find(item => shields.some(s => s.name === item)) || '';
            
            // Reset other equipment slots
            game.player.helmet = '';
            game.player.gloves = '';
            game.player.boots = '';
            
            // Calculate starting stats
            const weaponData = weapons.find(w => w.name === game.player.weapon);
            game.player.baseAttack = weaponData ? weaponData.attack : 15;
            
            recalculateDefense();
            
            game.needsClass = false;
            game.started = true;
            game.phase = 'exploration';
            
            generateDungeon();
            
            let messages = [
                `You are now a ${classData.name}.`,
                `Health: ${classData.health}. Mana: ${classData.mana}. Starting gold: ${classData.gold}.`
            ];
            
            if (game.player.weapon && game.player.armor) {
                messages.push(`Equipped: ${game.player.weapon} and ${game.player.armor}.`);
            }
            
            if (game.player.shield) {
                messages.push(`Shield: ${game.player.shield}.`);
            }
            
            messages.push(`Your special ability is ${classData.special.name}. It costs ${classData.special.cost} mana and deals ${classData.special.damage} damage.`);
            messages.push('Your adventure begins! What is your character name? Say save game as followed by your name to create your character.');
            
            speakSequence(messages, () => {
                setTimeout(() => describeRoom(), 1500);
            });
        }

        // ------------------------------------------------------------
        // SECTION 31: GAME INITIALIZATION
        // ------------------------------------------------------------
        
        function initializeGame() {
            checkBrowserSupport();
            game.initialized = true;
            micButton.classList.remove('start-button');
            
            // Speak tips, readme info at start
            const welcomeMessages = [
                "Welcome to Echo Dungeon Version 11, Blind First Edition!",
                gameInfo.readme,
                "Here's a helpful tip: " + gameInfo.tips[Math.floor(Math.random() * gameInfo.tips.length)],
                "Say load game to continue a saved character, or choose your class: warrior, mage, or rogue."
            ];
            
            speakSequence(welcomeMessages);
        }

        function handleClick() {
            if (!game.initialized) {
                initializeGame();
            } else {
                startListening();
            }
        }

        // ------------------------------------------------------------
        // SECTION 32: EXPERIENCE AND LEVELING
        // ------------------------------------------------------------
        
        function gainExperience(exp) {
            let actualExp = exp;
            
            // Check for experience bonuses
            if (game.player.equippedAmulet) {
                const amuletData = amulets.find(a => a.name === game.player.equippedAmulet);
                if (amuletData && amuletData.stat === 'expGain') {
                    actualExp = Math.floor(exp * 1.2);
                }
            }
            
            if (game.player.specialItems.includes('Crystal of Experience')) {
                actualExp = Math.floor(actualExp * 2);
            }
            
            game.player.experience += actualExp;
            
            while (game.player.experience >= game.player.experienceToNext) {
                levelUp();
            }
        }

        function levelUp() {
            game.player.level++;
            game.player.experience -= game.player.experienceToNext;
            game.player.experienceToNext = Math.floor(game.player.experienceToNext * 1.20);
            
            // Stats increase with floor multiplier
            const multiplier = game.player.damageMultiplier;
            const healthGain = 20 * multiplier;
            const manaGain = 10 * multiplier;
            
            game.player.maxHealth += healthGain;
            game.player.health = game.player.maxHealth;
            game.player.maxMana += manaGain;
            game.player.mana = game.player.maxMana;
            
            speakSequence([
                `Level up! You are now level ${game.player.level}!`,
                `Max health increased by ${healthGain}!`,
                `Max mana increased by ${manaGain}!`,
                'Fully healed and restored!'
            ]);
        }

        // ------------------------------------------------------------
        // SECTION 33: DUNGEON GENERATION
        // ------------------------------------------------------------
        
        function getRandomDescription(roomType) {
            const descriptions = roomTypes[roomType].descriptions;
            return descriptions[Math.floor(Math.random() * descriptions.length)];
        }

        function scaleEnemyForLevel(enemy, level) {
            const scaleFactor = 1 + ((level - 1) * 0.3);
            const floorMultiplier = getFloorMultiplier();
            
            return {
                ...enemy,
                health: Math.floor(enemy.health * scaleFactor * floorMultiplier),
                damage: Math.floor(enemy.damage * scaleFactor * floorMultiplier),
                gold: Math.floor(enemy.gold * scaleFactor),
                exp: Math.floor(enemy.exp * scaleFactor),
                regenerate: enemy.regenerate ? Math.floor(enemy.regenerate * floorMultiplier) : undefined
            };
        }

        function generateDungeon() {
            const size = game.dungeon.size;
            const currentLevel = game.dungeon.currentLevel;
            game.dungeon.grid = {};
            
            const centerX = 6;
            const centerY = 6;
            
            for (let x = 0; x < size; x++) {
                for (let y = 0; y < size; y++) {
                    const key = `${x},${y}`;
                    const distanceX = Math.abs(x - centerX);
                    const distanceY = Math.abs(y - centerY);
                    const distanceFromCenter = distanceX + distanceY;
                    
                    let roomData = { visited: false, searched: false, hasChest: false, fountainUsed: false };
                    
                    // Entrance at center
                    if (x === centerX && y === centerY) {
                        game.dungeon.grid[key] = {
                            type: 'entrance',
                            description: getRandomDescription('entrance'),
                            ...roomData
                        };
                    }
                    // Boss room at far corner
                    else if (x === size - 1 && y === size - 1) {
                        let bossEnemy = null;
                        
                        if (currentLevel >= 20) {
                            bossEnemy = scaleEnemyForLevel(enemies.apocalypseTitan, currentLevel);
                        } else if (currentLevel >= 10) {
                            bossEnemy = scaleEnemyForLevel(enemies.voidEmperor, currentLevel);
                        } else {
                            bossEnemy = scaleEnemyForLevel(enemies.dragon, currentLevel);
                        }
                        
                        game.dungeon.grid[key] = {
                            type: 'boss',
                            description: getRandomDescription('boss'),
                            ...roomData,
                            hasChest: true,
                            enemy: bossEnemy
                        };
                    }
                    // Stairs near boss
                    else if (x === size - 1 && y === size - 2) {
                        game.dungeon.grid[key] = {
                            type: 'stairs',
                            description: getRandomDescription('stairs'),
                            ...roomData
                        };
                    }
                    // Generate other rooms
                    else {
                        generateRoom(key, distanceFromCenter, currentLevel, roomData);
                    }
                }
            }
            
            // Maybe add secret room
            if (Math.random() < 0.3) {
                game.dungeon.hasSecretRoom = true;
            }
            
            // Set player position and current room
            game.player.position = { x: centerX, y: centerY };
            const key = `${game.player.position.x},${game.player.position.y}`;
            game.currentRoom = game.dungeon.grid[key];
            
            // Apply floor scaling
            applyFloorScaling();
        }

        function generateRoom(key, distanceFromCenter, currentLevel, roomData) {
            const roll = Math.random();
            const isElite = currentLevel >= 2 && Math.random() < 0.15;
            
            // 10% chance for merchant
            if (Math.random() < 0.1) {
                game.dungeon.grid[key] = {
                    type: 'merchant',
                    description: getRandomDescription('merchant'),
                    ...roomData
                };
                return;
            }
            
            let roomType = null;
            let enemyType = null;
            
            // Far from center - harder rooms
            if (distanceFromCenter >= 7) {
                if (roll < 0.5) {
                    roomType = 'enemy';
                    enemyType = selectEnemyType(currentLevel, 'far', isElite);
                } else if (roll < 0.7) {
                    roomType = 'treasure';
                    roomData.hasChest = true;
                } else if (roll < 0.8) {
                    roomType = 'fountain';
                } else {
                    roomType = 'crypt';
                    roomData.hasChest = Math.random() < 0.3;
                }
            }
            // Medium distance
            else if (distanceFromCenter >= 4) {
                if (roll < 0.45) {
                    roomType = 'enemy';
                    enemyType = selectEnemyType(currentLevel, 'medium', isElite);
                } else if (roll < 0.65) {
                    roomType = 'treasure';
                    roomData.hasChest = true;
                } else if (roll < 0.75) {
                    roomType = 'trap';
                } else if (roll < 0.8) {
                    roomType = 'fountain';
                } else {
                    roomType = 'empty';
                    roomData.hasChest = Math.random() < 0.2;
                }
            }
            // Near center - easier rooms
            else {
                if (roll < 0.35) {
                    roomType = 'enemy';
                    enemyType = selectEnemyType(currentLevel, 'near', isElite);
                } else if (roll < 0.55) {
                    roomType = 'treasure';
                    roomData.hasChest = true;
                } else if (roll < 0.6) {
                    roomType = 'fountain';
                } else {
                    roomType = 'empty';
                    roomData.hasChest = Math.random() < 0.15;
                }
            }
            
            if (roomType === 'enemy' && enemyType) {
                let scaledEnemy = scaleEnemyForLevel(enemies[enemyType], currentLevel);
                
                // Chance for double enemy encounter
                if (currentLevel >= 3 && Math.random() < 0.2) {
                    game.dungeon.grid[key] = {
                        type: 'enemy',
                        description: getRandomDescription('enemy') + ' Two creatures lurk here!',
                        ...roomData,
                        enemy: scaledEnemy,
                        secondEnemy: scaleEnemyForLevel(enemies[enemyType], currentLevel)
                    };
                } else {
                    game.dungeon.grid[key] = {
                        type: 'enemy',
                        description: getRandomDescription('enemy'),
                        ...roomData,
                        enemy: scaledEnemy
                    };
                }
            } else {
                game.dungeon.grid[key] = {
                    type: roomType,
                    description: getRandomDescription(roomType),
                    ...roomData
                };
            }
        }

        function selectEnemyType(currentLevel, distance, isElite) {
            if (currentLevel >= 20) {
                if (distance === 'far') return isElite ? 'harbingerOfRagnarok' : 'titanLord';
                if (distance === 'medium') return isElite ? 'voidBeast' : 'cosmicHorror';
                return isElite ? 'demonLord' : 'ancientDragon';
            }
            if (currentLevel >= 10) {
                if (distance === 'far') return isElite ? 'ancientDragon' : 'voidBeast';
                if (distance === 'medium') return isElite ? 'lichKing' : 'demonLord';
                return isElite ? 'archDemon' : 'hydra';
            }
            if (currentLevel >= 5) {
                if (distance === 'far') return isElite ? 'archDemon' : 'hydra';
                if (distance === 'medium') return isElite ? 'elderTroll' : 'demon';
                return isElite ? 'ancientWraith' : 'vampire';
            }
            if (currentLevel >= 3) {
                if (distance === 'far') return isElite ? 'elderTroll' : 'demon';
                if (distance === 'medium') return isElite ? 'orcChieftain' : 'wraith';
                return isElite ? 'orc' : 'troll';
            }
            // Levels 1-2
            if (distance === 'far') return isElite ? 'orcChieftain' : 'troll';
            if (distance === 'medium') return isElite ? 'orc' : 'wraith';
            return 'goblin';
        }

        // ------------------------------------------------------------
        // END OF PIECE 4
        // Piece 5 will contain: Movement, Room Description,
        // Room Interactions (Search, Chest, Fountain, Stairs)
        // ------------------------------------------------------------
                // ------------------------------------------------------------
        // PIECE 5: MOVEMENT, ROOM DESCRIPTIONS, ROOM INTERACTIONS
        // Continue directly after Piece 4
        // ------------------------------------------------------------

        // ------------------------------------------------------------
        // SECTION 34: MOVEMENT SYSTEM
        // ------------------------------------------------------------
        
        function move(direction) {
            const { x, y } = game.player.position;
            let newX = x, newY = y;
            
            if (direction === 'north') newY--;
            else if (direction === 'south') newY++;
            else if (direction === 'east') newX++;
            else if (direction === 'west') newX--;
            
            // Check boundaries
            if (newX < 0 || newX >= game.dungeon.size || newY < 0 || newY >= game.dungeon.size) {
                speak('You cannot go that way. A solid wall blocks your path.');
                return;
            }
            
            // Update position
            game.player.position = { x: newX, y: newY };
            const key = `${newX},${newY}`;
            game.currentRoom = game.dungeon.grid[key];
            
            // Handle trap rooms
            if (game.currentRoom.type === 'trap') {
                if (!game.currentRoom.visited) {
                    const trapDamage = Math.floor((15 + (game.dungeon.currentLevel * 5)) * game.player.damageMultiplier);
                    game.player.health -= trapDamage;
                    speak(`A trap springs! You take ${trapDamage} damage! Health: ${game.player.health}.`);
                    if (game.player.health <= 0) {
                        setTimeout(() => gameOver(), 1000);
                        return;
                    }
                }
            }
            
            game.currentRoom.visited = true;
            describeRoom();
        }

        // ------------------------------------------------------------
        // SECTION 35: ROOM DESCRIPTION
        // ------------------------------------------------------------
        
        function describeRoom() {
            const room = game.currentRoom;
            const messages = [`You are on Level ${game.dungeon.currentLevel} in ${room.description}`];
            
            if (room.type === 'stairs') {
                messages.push('Dark stairs descend deeper. Say go down stairs to descend.');
            } else if (room.type === 'merchant') {
                messages.push('A traveling merchant is here. Say merchant to trade.');
            } else if (room.type === 'fountain' && !room.fountainUsed) {
                messages.push('A magical fountain bubbles here. Say swim in the fountain to be fully healed.');
            } else if (room.enemy && room.enemy.health > 0) {
                if (room.secondEnemy && room.secondEnemy.health > 0) {
                    messages.push(`A ${room.enemy.name} and a ${room.secondEnemy.name} block your path!`);
                } else {
                    messages.push(`A ${room.enemy.name} blocks your path!`);
                }
                speakSequence(messages, () => {
                    setTimeout(() => startCombat(room.enemy, room.secondEnemy), 1000);
                });
                return;
            } else {
                if (room.hasChest && !room.searched) {
                    messages.push('A treasure chest glimmers in the shadows. Say open chest to loot it.');
                }
                if (!room.searched && room.type !== 'stairs' && room.type !== 'entrance') {
                    messages.push('You could search this room.');
                }
            }
            
            messages.push('Which direction will you go?');
            speakSequence(messages);
        }

        // ------------------------------------------------------------
        // SECTION 36: SEARCH ROOM
        // ------------------------------------------------------------
        
        function searchRoom() {
            const room = game.currentRoom;
            
            if (room.searched) {
                speak('You already searched this room thoroughly.');
                return;
            }
            
            room.searched = true;
            
            // Check for secret room discovery
            if (game.dungeon.hasSecretRoom && !game.dungeon.secretRoom && Math.random() < 0.15) {
                game.dungeon.secretRoom = true;
                speakSequence([
                    'You found a hidden passage behind a loose stone!',
                    'Inside, ancient treasures await!'
                ]);
                game.player.inventory.push('Ring of Minor Mana', 'Health Potion', 'Amulet of Vitality');
                game.player.gold += 30 * game.dungeon.currentLevel;
                return;
            }
            
            // Normal loot
            const loot = determineLoot();
            if (loot.type === 'gold') {
                game.player.gold += loot.amount;
                speak(`You found ${loot.amount} gold hidden in the shadows.`);
            } else if (loot.type === 'item') {
                game.player.inventory.push(loot.item);
                speak(`You found a hidden ${loot.item}!`);
            } else if (loot.type === 'ring') {
                game.player.inventory.push(loot.item);
                speak(`You found a mystical ${loot.item}! Say wear ring to equip it.`);
            } else if (loot.type === 'amulet') {
                game.player.inventory.push(loot.item);
                speak(`You found a powerful ${loot.item}! Say equip amulet to wear it.`);
            } else if (loot.type === 'bracelet') {
                game.player.inventory.push(loot.item);
                speak(`You found a ${loot.item}! Say equip bracelet to wear it.`);
            } else {
                speak('You search carefully but find nothing of value.');
            }
        }

        // ------------------------------------------------------------
        // SECTION 37: LOOT GENERATION
        // ------------------------------------------------------------
        
        function determineLoot() {
            const level = game.dungeon.currentLevel;
            const roll = Math.random();
            const playerClass = game.player.class;
            
            // High level mythic gear
            if (level >= 20 && roll < 0.2) {
                const mythicWeapons = weapons.filter(w => w.minLevel >= 20 && w.class === playerClass);
                const mythicArmors = armors.filter(a => a.minLevel >= 20 && a.class === playerClass);
                const allMythic = [...mythicWeapons, ...mythicArmors];
                if (allMythic.length > 0) {
                    return { type: 'item', item: allMythic[Math.floor(Math.random() * allMythic.length)].name };
                }
            }
            
            // Legendary gear
            if (level >= 10 && roll < 0.2) {
                const legendaryWeapons = weapons.filter(w => w.minLevel >= 10 && w.class === playerClass);
                const legendaryArmors = armors.filter(a => a.minLevel >= 10 && a.class === playerClass);
                const allLegendary = [...legendaryWeapons, ...legendaryArmors];
                if (allLegendary.length > 0) {
                    return { type: 'item', item: allLegendary[Math.floor(Math.random() * allLegendary.length)].name };
                }
            }
            
            // Epic gear
            if (level >= 5 && roll < 0.15) {
                const epicWeapons = weapons.filter(w => w.value > 400 && w.class === playerClass);
                const epicArmors = armors.filter(a => a.value > 400 && a.class === playerClass);
                const epicBracelets = bracelets.filter(b => b.minLevel && b.minLevel >= 5);
                const allEpic = [...epicWeapons, ...epicArmors, ...epicBracelets];
                if (allEpic.length > 0) {
                    const item = allEpic[Math.floor(Math.random() * allEpic.length)];
                    if (epicBracelets.includes(item)) {
                        return { type: 'bracelet', item: item.name };
                    }
                    return { type: 'item', item: item.name };
                }
            }
            
            // Rare gear
            if (level >= 3 && roll < 0.25) {
                const rareItems = [
                    ...weapons.filter(w => w.value > 200 && w.class === playerClass),
                    ...armors.filter(a => a.value > 200 && a.class === playerClass),
                    ...bracelets.filter(b => !b.minLevel || b.minLevel <= 5)
                ];
                if (rareItems.length > 0) {
                    const item = rareItems[Math.floor(Math.random() * rareItems.length)];
                    if (bracelets.some(b => b.name === item.name)) {
                        return { type: 'bracelet', item: item.name };
                    }
                    return { type: 'item', item: item.name };
                }
            }
            
            // Potions
            if (roll < 0.35) {
                if (level >= 20 && Math.random() < 0.3) {
                    return { type: 'item', item: Math.random() < 0.5 ? 'Ultimate Health Potion' : 'Ultimate Mana Potion' };
                } else if (level >= 10 && Math.random() < 0.4) {
                    return { type: 'item', item: Math.random() < 0.5 ? 'Supreme Health Potion' : 'Supreme Mana Potion' };
                } else if (level >= 5 && Math.random() < 0.5) {
                    return { type: 'item', item: Math.random() < 0.5 ? 'Greater Health Potion' : 'Greater Mana Potion' };
                } else {
                    return { type: 'item', item: Math.random() < 0.5 ? 'Health Potion' : 'Mana Potion' };
                }
            }
            
            // Rings
            if (roll < 0.45) {
                const levelRings = rings.filter(r => !r.minLevel || r.minLevel <= level);
                return { type: 'ring', item: levelRings[Math.floor(Math.random() * levelRings.length)].name };
            }
            
            // Amulets
            if (roll < 0.55) {
                const levelAmulets = amulets.filter(a => !a.minLevel || a.minLevel <= level);
                return { type: 'amulet', item: levelAmulets[Math.floor(Math.random() * levelAmulets.length)].name };
            }
            
            // Bracelets
            if (roll < 0.65) {
                const levelBracelets = bracelets.filter(b => !b.minLevel || b.minLevel <= level);
                return { type: 'bracelet', item: levelBracelets[Math.floor(Math.random() * levelBracelets.length)].name };
            }
            
            // Gold
            return { type: 'gold', amount: Math.floor(Math.random() * 15) + (5 * level) };
        }

        function determineTreasure() {
            const treasure = treasures[Math.floor(Math.random() * treasures.length)];
            const level = game.dungeon.currentLevel;
            return { ...treasure, value: treasure.value * level };
        }

        // ------------------------------------------------------------
        // SECTION 38: OPEN CHEST
        // ------------------------------------------------------------
        
        function openChest() {
            const room = game.currentRoom;
            
            if (!room.hasChest) {
                speak('There is no chest here.');
                return;
            }
            
            if (room.searched) {
                speak('The chest is empty. You already looted it.');
                return;
            }
            
            room.searched = true;
            
            // Mimic chance
            if (Math.random() < 0.08) {
                const mimicDamage = Math.floor((30 + (game.dungeon.currentLevel * 10)) * game.player.damageMultiplier);
                game.player.health -= mimicDamage;
                
                speak(`The chest springs to life! It's a mimic! You take ${mimicDamage} damage! Health: ${game.player.health}.`, () => {
                    if (game.player.health <= 0) {
                        setTimeout(() => gameOver(), 1000);
                    } else {
                        const mimic = scaleEnemyForLevel({
                            name: 'Mimic',
                            health: 45,
                            damage: 12,
                            gold: 15,
                            exp: 25,
                            fleeChance: 0.5
                        }, game.dungeon.currentLevel);
                        setTimeout(() => startCombat(mimic), 1000);
                    }
                });
                return;
            }
            
            // Normal chest loot
            let messages = ['You open the ornate chest and discover:'];
            
            if (room.type === 'treasure' || room.type === 'boss') {
                // Rich treasure rooms
                const treasure1 = determineTreasure();
                const treasure2 = determineTreasure();
                game.player.gold += treasure1.value;
                game.player.gold += treasure2.value;
                messages.push(`${treasure1.name} worth ${treasure1.value} gold!`);
                messages.push(`${treasure2.name} worth ${treasure2.value} gold!`);
                
                if (Math.random() < 0.4) {
                    const potion = Math.random() < 0.5 ? 'Health Potion' : 'Mana Potion';
                    game.player.inventory.push(potion);
                    messages.push(`A ${potion}!`);
                }
                
                // Boss rooms have extra loot
                if (room.type === 'boss') {
                    const bonusGold = 100 * game.dungeon.currentLevel;
                    game.player.gold += bonusGold;
                    messages.push(`A pile of ${bonusGold} gold coins!`);
                    
                    // Guaranteed good item from boss
                    const bossLoot = determineLoot();
                    if (bossLoot.item) {
                        game.player.inventory.push(bossLoot.item);
                        messages.push(`A magnificent ${bossLoot.item}!`);
                    }
                }
            } else {
                // Normal room chest
                const loot1 = determineLoot();
                const loot2 = determineLoot();
                
                [loot1, loot2].forEach(loot => {
                    if (loot.type === 'gold') {
                        game.player.gold += loot.amount;
                        messages.push(`${loot.amount} gold.`);
                    } else if (loot.item) {
                        game.player.inventory.push(loot.item);
                        messages.push(`A ${loot.item}.`);
                    }
                });
            }
            
            // Chance for ability book
            if (Math.random() < 0.25) {
                const availableAbilities = abilities.filter(a =>
                    a.class === game.player.class &&
                    !game.player.learnedAbilities.includes(a.name) &&
                    !game.player.inventory.includes(a.name) &&
                    (!a.minLevel || a.minLevel <= game.dungeon.currentLevel)
                );
                
              if (availableAbilities.length > 0) {
    const ability = availableAbilities[Math.floor(Math.random() * availableAbilities.length)];
    const bookName = `Book of ${ability.name}`;
    game.player.inventory.push(bookName);
    messages.push(`A ${bookName}! Say read book to learn it.`);
              }
            }
            
            if (messages.length === 1) {
                messages.push('Nothing of value.');
            }
            
            speakSequence(messages);
        }

        // ------------------------------------------------------------
        // SECTION 39: FOUNTAIN
        // ------------------------------------------------------------
        
        function useFountain() {
            if (game.currentRoom.type !== 'fountain') {
                speak('There is no fountain here.');
                return;
            }
            if (game.currentRoom.fountainUsed) {
                speak('The fountain has run dry. Its magic is spent.');
                return;
            }
            
            game.currentRoom.fountainUsed = true;
            game.player.health = game.player.maxHealth;
            game.player.mana = game.player.maxMana;
            
            speak('You swim in the magical fountain. You are fully healed and restored!');
        }

        // ------------------------------------------------------------
        // SECTION 40: STAIRS - FLOOR TRANSITION WITH MILESTONE SPEECH
        // ------------------------------------------------------------
        
        function useStairs() {
            if (game.currentRoom.type !== 'stairs') {
                speak('There are no stairs here.');
                return;
            }
            
            // Check if boss is defeated
            const bossKey = `${game.dungeon.size - 1},${game.dungeon.size - 1}`;
            const bossRoom = game.dungeon.grid[bossKey];
            if (bossRoom.enemy && bossRoom.enemy.health > 0) {
                speak('You must defeat the boss in the boss room first.');
                return;
            }
            
            const oldLevel = game.dungeon.currentLevel;
            game.dungeon.currentLevel++;
            const newLevel = game.dungeon.currentLevel;
            
            // Check for milestone (every 10 floors)
            const milestoneMessage = getFloorMilestoneMessage(newLevel);
            
            // Apply new floor scaling
            applyFloorScaling();
            recalculateDefense();
            
            // Generate new dungeon
            generateDungeon();
            
            // Build messages
            let messages = [`You descend to Dungeon Level ${newLevel}.`];
            
            if (milestoneMessage) {
                messages.push(milestoneMessage);
                messages.push(`All your damage, defense, and abilities have doubled! Spell costs have also doubled.`);
            } else {
                messages.push('The air grows colder and more dangerous.');
            }
            
            speakSequence(messages, () => {
                setTimeout(() => describeRoom(), 1000);
            });
        }

        // ------------------------------------------------------------
        // SECTION 41: MERCHANT SYSTEM
        // ------------------------------------------------------------
        
        function talkToMerchant() {
            if (game.currentRoom.type !== 'merchant') {
                speak('There is no merchant here.');
                return;
            }
            game.merchantOpen = true;
            speak('A mysterious merchant greets you. Say what do you have to see wares, buy to purchase, sell junk to sell marked items, or leave to exit.');
        }

        function listMerchantWares() {
            const messages = ['The merchant offers:'];
            const level = game.dungeon.currentLevel;
            
            merchantItems.forEach(item => {
                if (item.minLevel && level < item.minLevel) return;
                
                // Filter by class for equipment
                if (item.class && item.class !== game.player.class) return;
                
                let itemDesc = `${item.name} for ${item.price} gold.`;
                
                if (item.healing) itemDesc += ` Restores ${item.healing} health.`;
                if (item.mana) itemDesc += ` Restores ${item.mana} mana.`;
                if (item.description) itemDesc += ` ${item.description}.`;
                if (item.effect) itemDesc += ` ${item.effect}.`;
                
                messages.push(itemDesc);
            });
            
            messages.push('Say buy followed by the item name to purchase.');
            speakSequence(messages);
        }

        function buyFromMerchant(command) {
            let itemToBuy = null;
            
            for (let item of merchantItems) {
                if (command.includes(item.name.toLowerCase())) {
                    if (item.minLevel && game.dungeon.currentLevel < item.minLevel) {
                        speak(`${item.name} requires dungeon level ${item.minLevel}. Come back later.`);
                        return;
                    }
                    if (item.class && item.class !== game.player.class) {
                        continue; // Skip items for other classes
                    }
                    itemToBuy = item;
                    break;
                }
            }
            
            if (!itemToBuy) {
                speak('Item not recognized or not for your class. Say what do you have to see available items.');
                return;
            }
            
            if (game.player.gold < itemToBuy.price) {
                speak(`Not enough gold. You need ${itemToBuy.price} gold but only have ${game.player.gold}.`);
                return;
            }
            
            game.player.gold -= itemToBuy.price;
            
            // Handle different item types
            if (itemToBuy.type === 'potion') {
                game.player.inventory.push(itemToBuy.name);
                speak(`You bought ${itemToBuy.name} for ${itemToBuy.price} gold. Remaining gold: ${game.player.gold}.`);
            } else if (itemToBuy.type === 'special_potion') {
                game.player.inventory.push(itemToBuy.name);
                speak(`You bought ${itemToBuy.name} for ${itemToBuy.price} gold! ${itemToBuy.description}. Remaining gold: ${game.player.gold}.`);
            } else if (itemToBuy.type === 'special_item') {
                game.player.specialItems.push(itemToBuy.name);
                speak(`You bought ${itemToBuy.name} for ${itemToBuy.price} gold! ${itemToBuy.effect}. This is now permanently active!`);
            } else if (itemToBuy.type === 'special_ring') {
                game.player.inventory.push(itemToBuy.name);
                speak(`You bought ${itemToBuy.name} for ${itemToBuy.price} gold! ${itemToBuy.effect}. Say wear ring to equip it.`);
            } else if (itemToBuy.type === 'special_amulet') {
                game.player.inventory.push(itemToBuy.name);
                speak(`You bought ${itemToBuy.name} for ${itemToBuy.price} gold! Say equip amulet to wear it.`);
            } else {
                game.player.inventory.push(itemToBuy.name);
                speak(`You bought ${itemToBuy.name} for ${itemToBuy.price} gold. Remaining gold: ${game.player.gold}.`);
            }
        }

        function leaveMerchant() {
            game.merchantOpen = false;
            speak('You leave the merchant.');
        }

        // ------------------------------------------------------------
        // SECTION 42: MEDITATE (Mana Recovery)
        // ------------------------------------------------------------
        
        function meditate() {
            if (game.combat) {
                speak('You cannot meditate during combat!');
                return;
            }
            
            if (game.player.mana === game.player.maxMana) {
                speak('You are already at full mana.');
                return;
            }
            
            const manaRestored = Math.floor(25 * game.player.manaMultiplier);
            const previousMana = game.player.mana;
            game.player.mana = Math.min(game.player.maxMana, game.player.mana + manaRestored);
            const actualRestored = game.player.mana - previousMana;
            
            speak(`You meditate and restore ${actualRestored} mana. Current mana: ${game.player.mana}.`);
        }

        // ------------------------------------------------------------
        // SECTION 43: LOCKPICKS (Rogue Ability)
        // ------------------------------------------------------------
        
        function useLockpicks() {
            if (!game.player.inventory.includes('Lockpicks')) {
                speak('You do not have lockpicks. Rogues start with them.');
                return;
            }
            
            if (game.currentRoom.hasChest && !game.currentRoom.searched) {
                speak('You expertly pick the lock on the chest!');
                openChest();
            } else {
                speak('There is nothing to pick here.');
            }
        }

        // ------------------------------------------------------------
        // END OF PIECE 5
        // Piece 6 will contain: Combat System (Attack, Defend, Special,
        // Spells, Enemy Turns, Victory, Flee)
        // ------------------------------------------------------------
                // ------------------------------------------------------------
        // PIECE 6: COMPLETE COMBAT SYSTEM
        // Continue directly after Piece 5
        // ------------------------------------------------------------

        // ------------------------------------------------------------
        // SECTION 44: START COMBAT
        // ------------------------------------------------------------
        
        function startCombat(enemy, secondEnemy = null) {
            game.combat = {
                enemy: { ...enemy },
                secondEnemy: secondEnemy ? { ...secondEnemy } : null,
                playerDefending: false,
                twoEnemyFight: secondEnemy ? true : false,
                playerShadowmelded: false
            };
            game.phase = 'combat';
            
            let messages = ['Combat begins!', `${enemy.name} has ${enemy.health} health.`];
            
            if (secondEnemy) {
                messages.push(`${secondEnemy.name} has ${secondEnemy.health} health.`);
                messages.push('You face two enemies!');
            }
            
            if (enemy.regenerate) {
                messages.push(`Warning: ${enemy.name} regenerates ${enemy.regenerate} health per turn!`);
            }
            if (secondEnemy && secondEnemy.regenerate) {
                messages.push(`Warning: ${secondEnemy.name} regenerates ${secondEnemy.regenerate} health per turn!`);
            }
            
            messages.push('What will you do? Attack, defend, special, cast spell, use potion, or flee.');
            
            speakSequence(messages);
        }

        // ------------------------------------------------------------
        // SECTION 45: PLAYER ATTACK
        // ------------------------------------------------------------
        
        function playerAttack() {
            if (!game.combat) return;
            
            let damage = calculateTotalAttack();
            
            // Add randomness
            damage += Math.floor(Math.random() * 10);
            
            // Check for strength effect (double damage)
            const strengthEffect = game.player.activeEffects.find(e => e.type === 'strength');
            if (strengthEffect) {
                damage = Math.floor(damage * 2);
            }
            
            // Shadowmeld bonus (200% damage)
            if (game.combat.playerShadowmelded) {
                damage = Math.floor(damage * 2);
                game.combat.playerShadowmelded = false;
            }
            
            // Death Mark bonus (50% more damage)
            if (game.combat.enemy.deathMarked) {
                damage = Math.floor(damage * 1.5);
            }
            
            game.combat.enemy.health -= damage;
            
            let messages = [`You attack for ${damage} damage!`];
            
            if (strengthEffect) {
                messages.push('Giant Strength doubles your damage!');
            }
            if (game.combat.enemy.deathMarked) {
                messages.push('Death Mark amplifies your strike!');
            }
            
            messages.push(`${game.combat.enemy.name} has ${Math.max(0, game.combat.enemy.health)} health left.`);
            
            speakSequence(messages, () => {
                if (game.combat.enemy.health <= 0) {
                    handleEnemyDefeated();
                } else {
                    setTimeout(() => enemyTurn(), 1000);
                }
            });
        }

        // ------------------------------------------------------------
        // SECTION 46: PLAYER DEFEND
        // ------------------------------------------------------------
        
        function playerDefend() {
            if (!game.combat) return;
            
            game.combat.playerDefending = true;
            speak('You brace for impact. Incoming damage will be halved.', () => {
                setTimeout(() => enemyTurn(), 1000);
            });
        }

        // ------------------------------------------------------------
        // SECTION 47: PLAYER SPECIAL ABILITY
        // ------------------------------------------------------------
        
        function playerSpecial() {
            if (!game.combat) return;
            
            const classData = classes[game.player.class];
            const special = classData.special;
            
            // Calculate mana cost with floor multiplier
            let manaCost = Math.floor(special.cost * game.player.manaMultiplier);
            
            // Check for clarity effect (50% less mana)
            const clarityEffect = game.player.activeEffects.find(e => e.type === 'clarity');
            if (clarityEffect) {
                manaCost = Math.floor(manaCost * 0.5);
            }
            
            if (game.player.mana < manaCost) {
                speak(`Not enough mana. You need ${manaCost}.`);
                return;
            }
            
            game.player.mana -= manaCost;
            
            // Calculate damage with floor multiplier
            let damage = Math.floor(special.damage * game.player.damageMultiplier);
            
            // Add level bonus
            if (game.player.class === 'warrior' || game.player.class === 'rogue') {
                damage += (game.player.level - 1) * 5 * game.player.damageMultiplier;
            } else if (game.player.class === 'mage') {
                damage += (game.player.level - 1) * 6 * game.player.damageMultiplier;
            }
            
            game.combat.enemy.health -= damage;
            
            speakSequence([
                `You unleash ${special.name}!`,
                `${damage} damage!`,
                `${game.combat.enemy.name} has ${Math.max(0, game.combat.enemy.health)} health left.`
            ], () => {
                if (game.combat.enemy.health <= 0) {
                    handleEnemyDefeated();
                } else {
                    setTimeout(() => enemyTurn(), 1000);
                }
            });
        }

        // ------------------------------------------------------------
        // SECTION 48: CAST SPELL (Learned Abilities)
        // ------------------------------------------------------------
        
        function castSpell(command) {
            if (!game.combat) {
                speak('You can only cast spells in combat.');
                return;
            }
            
            // Find the spell in command
            let spellToCast = null;
            for (let ability of abilities) {
                if (command.includes(ability.name.toLowerCase()) && game.player.learnedAbilities.includes(ability.name)) {
                    spellToCast = ability;
                    break;
                }
            }
            
            if (!spellToCast) {
                const learned = game.player.learnedAbilities.join(', ');
                if (learned) {
                    speak(`You know: ${learned}. Say which spell to cast.`);
                } else {
                    speak('You have not learned any spells yet. Find ability books in chests.');
                }
                return;
            }
            
            // Calculate mana cost with floor multiplier
            let spellCost = Math.floor(spellToCast.cost * game.player.manaMultiplier);
            
            // Check for clarity effect
            const clarityEffect = game.player.activeEffects.find(e => e.type === 'clarity');
            if (clarityEffect) {
                spellCost = Math.floor(spellCost * 0.5);
            }
            
            if (game.player.mana < spellCost) {
                speak(`Not enough mana. You need ${spellCost} mana.`);
                return;
            }
            
            game.player.mana -= spellCost;
            
            // Calculate base damage with floor multiplier
            let baseDamage = Math.floor(spellToCast.damage * game.player.damageMultiplier);
            
            // Add level bonus
            let levelBonus = 0;
            if (game.player.class === 'mage') {
                levelBonus = game.player.level * 6 * game.player.damageMultiplier;
            } else {
                levelBonus = game.player.level * 5 * game.player.damageMultiplier;
            }
            
            const totalDamage = baseDamage + levelBonus;
            
            // Execute spell based on type
            executeSpellByType(spellToCast, totalDamage);
        }

        function executeSpellByType(spell, damage) {
            switch (spell.type) {
                case 'freeze':
                    game.combat.enemy.health -= damage;
                    game.combat.enemy.frozen = true;
                    speakSequence([
                        `You cast ${spell.name}!`,
                        `Icy shards pierce the ${game.combat.enemy.name} for ${damage} damage!`,
                        'The enemy is frozen solid for 1 turn!',
                        `${game.combat.enemy.name} has ${Math.max(0, game.combat.enemy.health)} health left.`
                    ], () => checkPostSpellState());
                    break;
                    
                case 'stun':
                    game.combat.enemy.health -= damage;
                    game.combat.enemy.stunned = true;
                    speakSequence([
                        `You cast ${spell.name}!`,
                        `${damage} damage!`,
                        `${game.combat.enemy.name} is stunned!`,
                        `${game.combat.enemy.name} has ${Math.max(0, game.combat.enemy.health)} health left.`
                    ], () => checkPostSpellState());
                    break;
                    
                case 'poison':
                    game.combat.enemy.health -= damage;
                    const poisonDamage = Math.floor((15 + game.player.level * 1.5) * game.player.damageMultiplier);
                    game.combat.enemy.poisoned = { damage: poisonDamage, duration: spell.duration };
                    speakSequence([
                        `You cast ${spell.name}!`,
                        `${damage} initial damage!`,
                        `Poison will deal ${poisonDamage} per turn for ${spell.duration} turns!`,
                        `${game.combat.enemy.name} has ${Math.max(0, game.combat.enemy.health)} health left.`
                    ], () => checkPostSpellState());
                    break;
                    
                case 'aoe':
                    game.combat.enemy.health -= damage;
                    let aoeMessages = [
                        `You cast ${spell.name}!`,
                        `${damage} damage to ${game.combat.enemy.name}!`
                    ];
                    
                    if (game.combat.secondEnemy && game.combat.secondEnemy.health > 0) {
                        game.combat.secondEnemy.health -= damage;
                        aoeMessages.push(`${damage} damage to ${game.combat.secondEnemy.name}!`);
                    }
                    
                    aoeMessages.push(`${game.combat.enemy.name} has ${Math.max(0, game.combat.enemy.health)} health left.`);
                    
                    if (game.combat.secondEnemy && game.combat.secondEnemy.health > 0) {
                        aoeMessages.push(`${game.combat.secondEnemy.name} has ${Math.max(0, game.combat.secondEnemy.health)} health left.`);
                    }
                    
                    speakSequence(aoeMessages, () => {
                        if (game.combat.enemy.health <= 0 && (!game.combat.secondEnemy || game.combat.secondEnemy.health <= 0)) {
                            setTimeout(() => combatVictory(), 1000);
                        } else if (game.combat.enemy.health <= 0 && game.combat.secondEnemy && game.combat.secondEnemy.health > 0) {
                            game.combat.enemy = game.combat.secondEnemy;
                            game.combat.secondEnemy = null;
                            speak(`${game.combat.enemy.name} remains!`, () => {
                                setTimeout(() => enemyTurn(), 1000);
                            });
                        } else {
                            setTimeout(() => enemyTurn(), 1000);
                        }
                    });
                    break;
                    
                case 'sneak':
                    game.combat.enemy.health -= damage;
                    speakSequence([
                        `You strike from the shadows!`,
                        `${damage} damage!`,
                        'The enemy cannot counter your stealth attack!',
                        `${game.combat.enemy.name} has ${Math.max(0, game.combat.enemy.health)} health left.`
                    ], () => {
                        if (game.combat.enemy.health <= 0) {
                            handleEnemyDefeated();
                        } else {
                            // Sneak attacks don't trigger enemy turn
                            speak('What will you do?');
                        }
                    });
                    break;
                    
                case 'timestop':
                    game.combat.enemy.frozen = true;
                    game.combat.enemy.timestopTurns = 2;
                    if (game.combat.secondEnemy && game.combat.secondEnemy.health > 0) {
                        game.combat.secondEnemy.frozen = true;
                        game.combat.secondEnemy.timestopTurns = 2;
                    }
                    speakSequence([
                        'You cast Time Stop!',
                        'Time freezes around you!',
                        'All enemies are frozen for 2 turns!'
                    ], () => {
                        speak('What will you do?');
                    });
                    break;
                    
                case 'rage':
                    const rageDamage = damage * 3;
                    game.combat.enemy.health -= rageDamage;
                    speakSequence([
                        'You enter a berserker rage!',
                        `You strike three times for ${rageDamage} total damage!`,
                        `${game.combat.enemy.name} has ${Math.max(0, game.combat.enemy.health)} health left.`
                    ], () => checkPostSpellState());
                    break;
                    
                case 'vanish':
                    game.combat.playerShadowmelded = true;
                    speakSequence([
                        'You meld into the shadows!',
                        'You become invisible!',
                        'Your next attack will deal 200% damage!'
                    ], () => {
                        speak('What will you do?');
                    });
                    break;
                    
                case 'mark':
                    game.combat.enemy.health -= damage;
                    game.combat.enemy.deathMarked = true;
                    speakSequence([
                        'You cast Death Mark!',
                        `${damage} damage!`,
                        'The enemy is marked! They take 50% more damage!',
                        `${game.combat.enemy.name} has ${Math.max(0, game.combat.enemy.health)} health left.`
                    ], () => checkPostSpellState());
                    break;
                    
                case 'damage':
                default:
                    game.combat.enemy.health -= damage;
                    speakSequence([
                        `You cast ${spell.name}!`,
                        `${damage} damage!`,
                        `${game.combat.enemy.name} has ${Math.max(0, game.combat.enemy.health)} health left.`
                    ], () => checkPostSpellState());
                    break;
            }
        }

        function checkPostSpellState() {
            if (game.combat.enemy.health <= 0) {
                handleEnemyDefeated();
            } else {
                setTimeout(() => enemyTurn(), 1000);
            }
        }

        // ------------------------------------------------------------
        // SECTION 49: ENEMY TURN
        // ------------------------------------------------------------
        
        function enemyTurn() {
            if (!game.combat) return;
            
            let messages = [];
            
            // Ring of Regeneration healing
            const regenRingCount = game.player.equippedRings.filter(r => r === 'Ring of Regeneration').length;
            if (regenRingCount > 0) {
                const regenAmount = 50 * regenRingCount;
                const oldHealth = game.player.health;
                game.player.health = Math.min(game.player.maxHealth, game.player.health + regenAmount);
                const actualHeal = game.player.health - oldHealth;
                if (actualHeal > 0) {
                    messages.push(`Your Ring${regenRingCount > 1 ? 's' : ''} of Regeneration heal${regenRingCount === 1 ? 's' : ''} you for ${actualHeal} health!`);
                }
            }
            
            // Process first enemy
            processEnemyAction(game.combat.enemy, messages);
            
            // Process second enemy if exists
            if (game.combat.secondEnemy && game.combat.secondEnemy.health > 0) {
                processEnemyAction(game.combat.secondEnemy, messages);
            }
            
            messages.push(`Your health: ${Math.max(0, game.player.health)}.`);
            
            speakSequence(messages, () => {
                if (game.player.health <= 0) {
                    setTimeout(() => gameOver(), 1000);
                } else {
                    setTimeout(() => speak('What will you do?'), 500);
                }
            });
        }

        function processEnemyAction(enemy, messages) {
            // Check if frozen
            if (enemy.frozen) {
                if (enemy.timestopTurns) {
                    enemy.timestopTurns--;
                    if (enemy.timestopTurns <= 0) {
                        enemy.frozen = false;
                        enemy.timestopTurns = 0;
                    }
                } else {
                    enemy.frozen = false;
                }
                messages.push(`${enemy.name} is frozen and cannot act!`);
                return;
            }
            
            // Check if stunned
            if (enemy.stunned) {
                messages.push(`${enemy.name} is stunned and cannot act!`);
                enemy.stunned = false;
                return;
            }
            
            // Enemy regeneration
            if (enemy.regenerate) {
                enemy.health += enemy.regenerate;
                messages.push(`${enemy.name} regenerates ${enemy.regenerate} health!`);
            }
            
            // Process poison damage
            if (enemy.poisoned) {
                enemy.health -= enemy.poisoned.damage;
                messages.push(`${enemy.name} takes ${enemy.poisoned.damage} poison damage!`);
                enemy.poisoned.duration--;
                if (enemy.poisoned.duration <= 0) {
                    enemy.poisoned = null;
                }
                if (enemy.health <= 0) {
                    messages.push(`${enemy.name} succumbs to poison!`);
                    return;
                }
            }
            
            // Enemy attacks
            let damage = enemy.damage;
            
            // Apply player defense
            if (game.combat.playerDefending) {
                damage = Math.floor(damage * 0.5);
                game.combat.playerDefending = false;
            }
            
            // Reduce by player defense stat
            const reducedDamage = Math.max(1, damage - game.player.defense);
            game.player.health -= reducedDamage;
            
            messages.push(`${enemy.name} attacks for ${reducedDamage} damage!`);
        }

        // ------------------------------------------------------------
        // SECTION 50: HANDLE ENEMY DEFEATED
        // ------------------------------------------------------------
        
        function handleEnemyDefeated() {
            if (game.combat.secondEnemy && game.combat.secondEnemy.health > 0) {
                game.combat.enemy = game.combat.secondEnemy;
                game.combat.secondEnemy = null;
                speak(`${game.combat.enemy.name} remains! Health: ${game.combat.enemy.health}.`, () => {
                    setTimeout(() => enemyTurn(), 1000);
                });
            } else {
                setTimeout(() => combatVictory(), 1000);
            }
        }

        // ------------------------------------------------------------
        // SECTION 51: COMBAT VICTORY
        // ------------------------------------------------------------
        
        function combatVictory() {
            if (!game.combat) return;
            
            let gold = game.combat.enemy.gold;
            let exp = game.combat.enemy.exp;
            
            // Lucky Coin bonus
            if (game.player.specialItems.includes("Merchant's Lucky Coin")) {
                gold = Math.floor(gold * 1.5);
            }
            
            // Double experience for two-enemy fights
            if (game.combat.twoEnemyFight) {
                exp = exp * 2;
            }
            
            game.player.gold += gold;
            
            // Mark room enemies as defeated
            if (game.currentRoom.enemy) {
                game.currentRoom.enemy.health = 0;
            }
            if (game.currentRoom.secondEnemy) {
                game.currentRoom.secondEnemy.health = 0;
            }
            
            const messages = [
                `${game.combat.enemy.name} defeated!`,
                `You gain ${gold} gold and ${exp} experience!`
            ];
            
            if (game.combat.twoEnemyFight) {
                messages.push('Double experience for defeating 2 enemies!');
            }
            
            // Process active effects
            const strengthEffect = game.player.activeEffects.find(e => e.type === 'strength');
            if (strengthEffect) {
                strengthEffect.battles--;
                if (strengthEffect.battles <= 0) {
                    game.player.activeEffects = game.player.activeEffects.filter(e => e.type !== 'strength');
                    messages.push('Giant Strength effect has worn off.');
                }
            }
            
            const clarityEffect = game.player.activeEffects.find(e => e.type === 'clarity');
            if (clarityEffect) {
                clarityEffect.battles--;
                if (clarityEffect.battles <= 0) {
                    game.player.activeEffects = game.player.activeEffects.filter(e => e.type !== 'clarity');
                    messages.push('Clarity effect has worn off.');
                }
            }
            
            speakSequence(messages, () => {
                game.combat = null;
                game.phase = 'exploration';
                gainExperience(exp);
                
                if (game.currentRoom.type === 'boss') {
                    setTimeout(() => dungeonLevelComplete(), 1500);
                } else {
                    setTimeout(() => speak('What will you do next?'), 1000);
                }
            });
        }

        function dungeonLevelComplete() {
            speakSequence([
                'You defeated the boss!',
                'The dungeon level is cleared!',
                'Seek the stairs to descend deeper!',
                `You are now level ${game.player.level} with ${game.player.gold} gold.`
            ]);
        }

        // ------------------------------------------------------------
        // SECTION 52: ATTEMPT FLEE
        // ------------------------------------------------------------
        
        function attemptFlee() {
            if (!game.combat) return;
            
            const chance = game.combat.enemy.fleeChance;
            const roll = Math.random();
            
            speak('Attempting to flee...', () => {
                setTimeout(() => {
                    if (roll < chance) {
                        speak('You successfully escape!', () => {
                            game.combat = null;
                            game.phase = 'exploration';
                            setTimeout(() => {
                                // Return to center
                                const centerX = 6;
                                const centerY = 6;
                                game.player.position = { x: centerX, y: centerY };
                                const key = `${centerX},${centerY}`;
                                game.currentRoom = game.dungeon.grid[key];
                                speak('You flee back to the entrance.');
                            }, 1000);
                        });
                    } else {
                        speak('You fail to escape!', () => {
                            setTimeout(() => enemyTurn(), 1000);
                        });
                    }
                }, 1000);
            });
        }

        // ------------------------------------------------------------
        // SECTION 53: GAME OVER
        // ------------------------------------------------------------
        
        function gameOver() {
            // Check for revive effect
            const reviveEffect = game.player.activeEffects.find(e => e.type === 'revive');
            if (reviveEffect && reviveEffect.uses > 0) {
                reviveEffect.uses--;
                game.player.activeEffects = game.player.activeEffects.filter(e => e.type !== 'revive');
                game.player.health = Math.floor(game.player.maxHealth * 0.5);
                
                speakSequence([
                    'You have fallen!',
                    'But the Elixir of Immortality revives you!',
                    `You return with ${game.player.health} health!`,
                    'What will you do?'
                ]);
                return;
            }
            
            speakSequence([
                'You have been defeated.',
                'Your adventure ends here.',
                `You reached level ${game.player.level} and collected ${game.player.gold} gold.`,
                `You descended to dungeon level ${game.dungeon.currentLevel}.`,
                'Game over. Tap to start a new game or say load game to continue a saved character.'
            ], () => {
                // Reset game state for new game
                game.combat = null;
                game.phase = 'init';
                game.needsClass = true;
                game.started = false;
            });
        }

        // ------------------------------------------------------------
        // END OF PIECE 6
        // Piece 7 will contain: Potion System, Equipment System,
        // Ability Books, Status/Inventory Commands
        // ------------------------------------------------------------
        // ------------------------------------------------------------
        // SECTION 54: POTION COMMAND ROUTER
        // ------------------------------------------------------------
        
        function processPotionCommand(command) {
            const potionTypes = [
                'Ultimate Health Potion', 'Ultimate Mana Potion',
                'Supreme Health Potion', 'Supreme Mana Potion',
                'Greater Health Potion', 'Greater Mana Potion',
                'Health Potion', 'Mana Potion',
                'Elixir of Immortality', 'Potion of Giant Strength', 'Elixir of Clarity'
            ];
            
            let foundPotion = null;
            
            // Check for specific potion in command
            for (let potion of potionTypes) {
                if (command.includes(potion.toLowerCase())) {
                    if (game.player.inventory.includes(potion)) {
                        foundPotion = potion;
                        break;
                    }
                }
            }
            
            // If no specific potion mentioned, try to find best available
            if (!foundPotion) {
                if (command.includes('health') || command.includes('heal')) {
                    const healthPotions = ['Ultimate Health Potion', 'Supreme Health Potion', 'Greater Health Potion', 'Health Potion'];
                    foundPotion = healthPotions.find(p => game.player.inventory.includes(p));
                } else if (command.includes('mana')) {
                    const manaPotions = ['Ultimate Mana Potion', 'Supreme Mana Potion', 'Greater Mana Potion', 'Mana Potion'];
                    foundPotion = manaPotions.find(p => game.player.inventory.includes(p));
                } else if (command.includes('immortality') || command.includes('revive')) {
                    foundPotion = game.player.inventory.includes('Elixir of Immortality') ? 'Elixir of Immortality' : null;
                } else if (command.includes('strength') || command.includes('giant')) {
                    foundPotion = game.player.inventory.includes('Potion of Giant Strength') ? 'Potion of Giant Strength' : null;
                } else if (command.includes('clarity')) {
                    foundPotion = game.player.inventory.includes('Elixir of Clarity') ? 'Elixir of Clarity' : null;
                }
            }
            
            if (!foundPotion) {
                // Try to find any potion
                foundPotion = potionTypes.find(p => game.player.inventory.includes(p));
            }
            
            if (!foundPotion) {
                speak('You have no potions to use.');
                return;
            }
            
            usePotion(foundPotion);
        }

        // ------------------------------------------------------------
        // SECTION 55: USE POTION
        // ------------------------------------------------------------
        
        function usePotion(potionType) {
            const index = game.player.inventory.indexOf(potionType);
            if (index === -1) {
                speak(`You don't have a ${potionType}.`);
                return;
            }
            
            game.player.inventory.splice(index, 1);
            
            if (potionType === 'Health Potion') {
                const heal = 50;
                const oldHealth = game.player.health;
                game.player.health = Math.min(game.player.maxHealth, game.player.health + heal);
                const actualHeal = game.player.health - oldHealth;
                speak(`You drink a health potion and restore ${actualHeal} health. Health: ${game.player.health}.`, () => {
                    if (game.combat) setTimeout(() => enemyTurn(), 1000);
                });
            } else if (potionType === 'Greater Health Potion') {
                const heal = 150;
                const oldHealth = game.player.health;
                game.player.health = Math.min(game.player.maxHealth, game.player.health + heal);
                const actualHeal = game.player.health - oldHealth;
                speak(`You drink a greater health potion and restore ${actualHeal} health. Health: ${game.player.health}.`, () => {
                    if (game.combat) setTimeout(() => enemyTurn(), 1000);
                });
            } else if (potionType === 'Supreme Health Potion') {
                const heal = 400;
                const oldHealth = game.player.health;
                game.player.health = Math.min(game.player.maxHealth, game.player.health + heal);
                const actualHeal = game.player.health - oldHealth;
                speak(`You drink a supreme health potion and restore ${actualHeal} health. Health: ${game.player.health}.`, () => {
                    if (game.combat) setTimeout(() => enemyTurn(), 1000);
                });
            } else if (potionType === 'Ultimate Health Potion') {
                game.player.health = game.player.maxHealth;
                speak(`You drink an ultimate health potion and fully restore your health! Health: ${game.player.health}.`, () => {
                    if (game.combat) setTimeout(() => enemyTurn(), 1000);
                });
            } else if (potionType === 'Mana Potion') {
                const restore = 30;
                const oldMana = game.player.mana;
                game.player.mana = Math.min(game.player.maxMana, game.player.mana + restore);
                const actualRestore = game.player.mana - oldMana;
                speak(`You drink a mana potion and restore ${actualRestore} mana. Mana: ${game.player.mana}.`, () => {
                    if (game.combat) setTimeout(() => enemyTurn(), 1000);
                });
            } else if (potionType === 'Greater Mana Potion') {
                const restore = 80;
                const oldMana = game.player.mana;
                game.player.mana = Math.min(game.player.maxMana, game.player.mana + restore);
                const actualRestore = game.player.mana - oldMana;
                speak(`You drink a greater mana potion and restore ${actualRestore} mana. Mana: ${game.player.mana}.`, () => {
                    if (game.combat) setTimeout(() => enemyTurn(), 1000);
                });
            } else if (potionType === 'Supreme Mana Potion') {
                const restore = 200;
                const oldMana = game.player.mana;
                game.player.mana = Math.min(game.player.maxMana, game.player.mana + restore);
                const actualRestore = game.player.mana - oldMana;
                speak(`You drink a supreme mana potion and restore ${actualRestore} mana. Mana: ${game.player.mana}.`, () => {
                    if (game.combat) setTimeout(() => enemyTurn(), 1000);
                });
            } else if (potionType === 'Ultimate Mana Potion') {
                game.player.mana = game.player.maxMana;
                speak(`You drink an ultimate mana potion and fully restore your mana! Mana: ${game.player.mana}.`, () => {
                    if (game.combat) setTimeout(() => enemyTurn(), 1000);
                });
            } else if (potionType === 'Elixir of Immortality') {
                game.player.activeEffects.push({ type: 'revive', uses: 1 });
                speak('You drink the Elixir of Immortality! You will revive once if you die.', () => {
                    if (game.combat) setTimeout(() => enemyTurn(), 1000);
                });
            } else if (potionType === 'Potion of Giant Strength') {
                game.player.activeEffects.push({ type: 'strength', battles: 3 });
                speak('You drink the Potion of Giant Strength! Your attacks deal double damage for 3 battles!', () => {
                    if (game.combat) setTimeout(() => enemyTurn(), 1000);
                });
            } else if (potionType === 'Elixir of Clarity') {
                game.player.activeEffects.push({ type: 'clarity', battles: 3 });
                speak('You drink the Elixir of Clarity! All spells cost 50% less mana for 3 battles!', () => {
                    if (game.combat) setTimeout(() => enemyTurn(), 1000);
                });
            }
        }

        // ------------------------------------------------------------
        // SECTION 56: RECALCULATE DEFENSE
        // ------------------------------------------------------------
        
        function recalculateDefense() {
            let totalDefense = 0;
            
            // Armor defense
            if (game.player.armor) {
                const armorData = armors.find(a => a.name === game.player.armor);
                if (armorData) totalDefense += armorData.defense;
            }
            
            // Shield defense
            if (game.player.shield) {
                const shieldData = shields.find(s => s.name === game.player.shield);
                if (shieldData) totalDefense += shieldData.defense;
            }
            
            // Helmet defense
            if (game.player.helmet) {
                const helmetData = helmets.find(h => h.name === game.player.helmet);
                if (helmetData && helmetData.defense) totalDefense += helmetData.defense;
            }
            
            // Boots defense
            if (game.player.boots) {
                const bootsData = boots.find(b => b.name === game.player.boots);
                if (bootsData && bootsData.defense) totalDefense += bootsData.defense;
            }
            
            // Apply floor multiplier
            totalDefense = Math.floor(totalDefense * game.player.defenseMultiplier);
            
            game.player.defense = totalDefense;
        }

        // ------------------------------------------------------------
        // SECTION 57: EQUIP GENERAL ITEM
        // ------------------------------------------------------------
        
        function equipItem(command) {
            // Check for weapon
            for (let weapon of weapons) {
                if (command.includes(weapon.name.toLowerCase()) || 
                    (command.includes('hidden') && command.includes(weapon.name.toLowerCase().split(' ').pop()))) {
                    if (weapon.class && weapon.class !== game.player.class) {
                        speak(`${weapon.name} is not for your class.`);
                        return;
                    }
                    if (!game.player.inventory.includes(weapon.name)) {
                        speak(`You don't have ${weapon.name} in your inventory.`);
                        return;
                    }
                    // Unequip current weapon
                    if (game.player.weapon) {
                        game.player.inventory.push(game.player.weapon);
                    }
                    // Remove from inventory and equip
                    const index = game.player.inventory.indexOf(weapon.name);
                    game.player.inventory.splice(index, 1);
                    game.player.weapon = weapon.name;
                    speak(`You equipped ${weapon.name}. Attack power: ${weapon.attack}.`);
                    return;
                }
            }
            
            // Check for armor
            for (let armor of armors) {
                if (command.includes(armor.name.toLowerCase()) ||
                    (command.includes('hidden') && command.includes(armor.name.toLowerCase().split(' ').pop()))) {
                    if (armor.class && armor.class !== game.player.class) {
                        speak(`${armor.name} is not for your class.`);
                        return;
                    }
                    if (!game.player.inventory.includes(armor.name)) {
                        speak(`You don't have ${armor.name} in your inventory.`);
                        return;
                    }
                    // Unequip current armor
                    if (game.player.armor) {
                        game.player.inventory.push(game.player.armor);
                    }
                    // Remove from inventory and equip
                    const index = game.player.inventory.indexOf(armor.name);
                    game.player.inventory.splice(index, 1);
                    game.player.armor = armor.name;
                    recalculateDefense();
                    speak(`You equipped ${armor.name}. Defense is now ${game.player.defense}.`);
                    return;
                }
            }
            
            // Check for shield
            for (let shield of shields) {
                if (command.includes(shield.name.toLowerCase()) ||
                    (command.includes('hidden') && command.includes(shield.name.toLowerCase().split(' ').pop()))) {
                    if (shield.class && shield.class !== game.player.class) {
                        speak(`${shield.name} is not for your class.`);
                        return;
                    }
                    if (!game.player.inventory.includes(shield.name)) {
                        speak(`You don't have ${shield.name} in your inventory.`);
                        return;
                    }
                    // Unequip current shield
                    if (game.player.shield) {
                        game.player.inventory.push(game.player.shield);
                    }
                    // Remove from inventory and equip
                    const index = game.player.inventory.indexOf(shield.name);
                    game.player.inventory.splice(index, 1);
                    game.player.shield = shield.name;
                    recalculateDefense();
                    speak(`You equipped ${shield.name}. Defense is now ${game.player.defense}.`);
                    return;
                }
            }
            
            // Check for helmet
            for (let helmet of helmets) {
                if (command.includes(helmet.name.toLowerCase()) ||
                    (command.includes('hidden') && command.includes(helmet.name.toLowerCase().split(' ').pop()))) {
                    if (helmet.class && helmet.class !== game.player.class) {
                        speak(`${helmet.name} is not for your class.`);
                        return;
                    }
                    if (!game.player.inventory.includes(helmet.name)) {
                        speak(`You don't have ${helmet.name} in your inventory.`);
                        return;
                    }
                    // Unequip current helmet
                    if (game.player.helmet) {
                        game.player.inventory.push(game.player.helmet);
                        // Remove mana bonus if applicable
                        const oldHelmet = helmets.find(h => h.name === game.player.helmet);
                        if (oldHelmet && oldHelmet.mana) {
                            game.player.maxMana -= oldHelmet.mana;
                            game.player.mana = Math.min(game.player.mana, game.player.maxMana);
                        }
                    }
                    // Remove from inventory and equip
                    const index = game.player.inventory.indexOf(helmet.name);
                    game.player.inventory.splice(index, 1);
                    game.player.helmet = helmet.name;
                    // Apply mana bonus if applicable
                    if (helmet.mana) {
                        game.player.maxMana += helmet.mana;
                        game.player.mana += helmet.mana;
                    }
                    recalculateDefense();
                    if (helmet.mana) {
                        speak(`You equipped ${helmet.name}. Max mana increased by ${helmet.mana}!`);
                    } else {
                        speak(`You equipped ${helmet.name}. Defense is now ${game.player.defense}.`);
                    }
                    return;
                }
            }
            
            // Check for gloves
            for (let glove of gloves) {
                if (command.includes(glove.name.toLowerCase()) ||
                    (command.includes('hidden') && command.includes(glove.name.toLowerCase().split(' ').pop()))) {
                    if (glove.class && glove.class !== game.player.class) {
                        speak(`${glove.name} is not for your class.`);
                        return;
                    }
                    if (!game.player.inventory.includes(glove.name)) {
                        speak(`You don't have ${glove.name} in your inventory.`);
                        return;
                    }
                    // Unequip current gloves
                    if (game.player.gloves) {
                        game.player.inventory.push(game.player.gloves);
                        const oldGloves = gloves.find(g => g.name === game.player.gloves);
                        if (oldGloves && oldGloves.mana) {
                            game.player.maxMana -= oldGloves.mana;
                            game.player.mana = Math.min(game.player.mana, game.player.maxMana);
                        }
                    }
                    // Remove from inventory and equip
                    const index = game.player.inventory.indexOf(glove.name);
                    game.player.inventory.splice(index, 1);
                    game.player.gloves = glove.name;
                    if (glove.mana) {
                        game.player.maxMana += glove.mana;
                        game.player.mana += glove.mana;
                        speak(`You equipped ${glove.name}. Max mana increased by ${glove.mana}!`);
                    } else {
                        speak(`You equipped ${glove.name}. Attack bonus: ${glove.attack}.`);
                    }
                    return;
                }
            }
            
            // Check for boots
            for (let boot of boots) {
                if (command.includes(boot.name.toLowerCase()) ||
                    (command.includes('hidden') && command.includes(boot.name.toLowerCase().split(' ').pop()))) {
                    if (boot.class && boot.class !== game.player.class) {
                        speak(`${boot.name} is not for your class.`);
                        return;
                    }
                    if (!game.player.inventory.includes(boot.name)) {
                        speak(`You don't have ${boot.name} in your inventory.`);
                        return;
                    }
                    // Unequip current boots
                    if (game.player.boots) {
                        game.player.inventory.push(game.player.boots);
                        const oldBoots = boots.find(b => b.name === game.player.boots);
                        if (oldBoots && oldBoots.mana) {
                            game.player.maxMana -= oldBoots.mana;
                            game.player.mana = Math.min(game.player.mana, game.player.maxMana);
                        }
                        if (oldBoots && oldBoots.health) {
                            game.player.maxHealth -= oldBoots.health;
                            game.player.health = Math.min(game.player.health, game.player.maxHealth);
                        }
                    }
                    // Remove from inventory and equip
                    const index = game.player.inventory.indexOf(boot.name);
                    game.player.inventory.splice(index, 1);
                    game.player.boots = boot.name;
                    if (boot.mana) {
                        game.player.maxMana += boot.mana;
                        game.player.mana += boot.mana;
                    }
                    if (boot.health) {
                        game.player.maxHealth += boot.health;
                        game.player.health += boot.health;
                    }
                    recalculateDefense();
                    if (boot.mana) {
                        speak(`You equipped ${boot.name}. Max mana increased by ${boot.mana}!`);
                    } else if (boot.health) {
                        speak(`You equipped ${boot.name}. Max health increased by ${boot.health}!`);
                    } else {
                        speak(`You equipped ${boot.name}. Defense is now ${game.player.defense}.`);
                    }
                    return;
                }
            }
            
            speak('Item not found or cannot be equipped. Check your inventory.');
        }

        // ------------------------------------------------------------
        // SECTION 58: EQUIP RING
        // ------------------------------------------------------------
        
        function equipRing(command) {
            const maxRings = 10;
            
            // Find the ring in command
            let ringToEquip = null;
            for (let ring of rings) {
                if (command.includes(ring.name.toLowerCase())) {
                    if (game.player.inventory.includes(ring.name)) {
                        ringToEquip = ring;
                        break;
                    }
                }
            }
            
            if (!ringToEquip) {
                speak('Ring not found in your inventory.');
                return;
            }
            
            if (game.player.equippedRings.length >= maxRings) {
                speak(`You can only wear ${maxRings} rings. Remove a ring first or sell one to the merchant.`);
                return;
            }
            
            // Remove from inventory
            const index = game.player.inventory.indexOf(ringToEquip.name);
            game.player.inventory.splice(index, 1);
            
            // Add to equipped rings
            game.player.equippedRings.push(ringToEquip.name);
            
            // Apply ring effects
            if (ringToEquip.mana) {
                game.player.maxMana += ringToEquip.mana;
                game.player.mana += ringToEquip.mana;
            }
            if (ringToEquip.health) {
                game.player.maxHealth += ringToEquip.health;
                game.player.health += ringToEquip.health;
            }
            
            speak(`You put on the ${ringToEquip.name}. You now have ${game.player.equippedRings.length} ring${game.player.equippedRings.length > 1 ? 's' : ''} equipped.`);
        }

        // ------------------------------------------------------------
        // SECTION 59: REMOVE RING
        // ------------------------------------------------------------
        
        function removeRing(command) {
            if (game.player.equippedRings.length === 0) {
                speak('You have no rings equipped.');
                return;
            }
            
            let ringToRemove = null;
            for (let ringName of game.player.equippedRings) {
                if (command.includes(ringName.toLowerCase())) {
                    ringToRemove = ringName;
                    break;
                }
            }
            
            if (!ringToRemove) {
                // If no specific ring mentioned, list equipped rings
                const ringList = game.player.equippedRings.join(', ');
                speak(`Which ring? You have: ${ringList}`);
                return;
            }
            
            // Find ring data
            const ringData = rings.find(r => r.name === ringToRemove);
            
            // Remove from equipped
            const index = game.player.equippedRings.indexOf(ringToRemove);
            game.player.equippedRings.splice(index, 1);
            
            // Add to inventory
            game.player.inventory.push(ringToRemove);
            
            // Remove ring effects
            if (ringData && ringData.mana) {
                game.player.maxMana -= ringData.mana;
                game.player.mana = Math.min(game.player.mana, game.player.maxMana);
            }
            if (ringData && ringData.health) {
                game.player.maxHealth -= ringData.health;
                game.player.health = Math.min(game.player.health, game.player.maxHealth);
            }
            
            speak(`You removed the ${ringToRemove} and placed it in your inventory.`);
        }

        // ------------------------------------------------------------
        // SECTION 60: EQUIP AMULET
        // ------------------------------------------------------------
        
        function equipAmulet(command) {
            let amuletToEquip = null;
            for (let amulet of amulets) {
                if (command.includes(amulet.name.toLowerCase())) {
                    if (game.player.inventory.includes(amulet.name)) {
                        amuletToEquip = amulet;
                        break;
                    }
                }
            }
            
            if (!amuletToEquip) {
                speak('Amulet not found in your inventory.');
                return;
            }
            
            // Unequip current amulet if any
            if (game.player.equippedAmulet) {
                const oldAmulet = amulets.find(a => a.name === game.player.equippedAmulet);
                game.player.inventory.push(game.player.equippedAmulet);
                if (oldAmulet) {
                    if (oldAmulet.mana) {
                        game.player.maxMana -= oldAmulet.mana;
                        game.player.mana = Math.min(game.player.mana, game.player.maxMana);
                    }
                    if (oldAmulet.health) {
                        game.player.maxHealth -= oldAmulet.health;
                        game.player.health = Math.min(game.player.health, game.player.maxHealth);
                    }
                }
            }
            
            // Remove from inventory
            const index = game.player.inventory.indexOf(amuletToEquip.name);
            game.player.inventory.splice(index, 1);
            
            // Equip amulet
            game.player.equippedAmulet = amuletToEquip.name;
            
            // Apply effects
            if (amuletToEquip.mana) {
                game.player.maxMana += amuletToEquip.mana;
                game.player.mana += amuletToEquip.mana;
            }
            if (amuletToEquip.health) {
                game.player.maxHealth += amuletToEquip.health;
                game.player.health += amuletToEquip.health;
            }
            
            speak(`You equipped the ${amuletToEquip.name}. ${amuletToEquip.effect}`);
        }

        // ------------------------------------------------------------
        // SECTION 61: EQUIP BRACELET (Ring-Style System)
        // ------------------------------------------------------------
        
        function equipBracelet(command) {
            const maxBracelets = 10;
            
            let braceletToEquip = null;
            for (let bracelet of bracelets) {
                if (command.includes(bracelet.name.toLowerCase())) {
                    if (game.player.inventory.includes(bracelet.name)) {
                        braceletToEquip = bracelet;
                        break;
                    }
                }
            }
            
            if (!braceletToEquip) {
                speak('Bracelet not found in your inventory.');
                return;
            }
            
            if (game.player.equippedBracelets.length >= maxBracelets) {
                speak(`You can only wear ${maxBracelets} bracelets. Remove one first.`);
                return;
            }
            
            // Remove from inventory
            const index = game.player.inventory.indexOf(braceletToEquip.name);
            game.player.inventory.splice(index, 1);
            
            // Add to equipped bracelets
            game.player.equippedBracelets.push(braceletToEquip.name);
            
            // Apply bracelet effects
            if (braceletToEquip.mana) {
                game.player.maxMana += braceletToEquip.mana;
                game.player.mana += braceletToEquip.mana;
            }
            
            speak(`You put on the ${braceletToEquip.name}. Attack +${braceletToEquip.attack}, Mana +${braceletToEquip.mana}. You have ${game.player.equippedBracelets.length} bracelet${game.player.equippedBracelets.length > 1 ? 's' : ''} equipped.`);
        }

        // ------------------------------------------------------------
        // SECTION 62: REMOVE BRACELET
        // ------------------------------------------------------------
        
        function removeBracelet(command) {
            if (game.player.equippedBracelets.length === 0) {
                speak('You have no bracelets equipped.');
                return;
            }
            
            let braceletToRemove = null;
            for (let braceletName of game.player.equippedBracelets) {
                if (command.includes(braceletName.toLowerCase())) {
                    braceletToRemove = braceletName;
                    break;
                }
            }
            
            if (!braceletToRemove) {
                const braceletList = game.player.equippedBracelets.join(', ');
                speak(`Which bracelet? You have: ${braceletList}`);
                return;
            }
            
            const braceletData = bracelets.find(b => b.name === braceletToRemove);
            
            // Remove from equipped
            const index = game.player.equippedBracelets.indexOf(braceletToRemove);
            game.player.equippedBracelets.splice(index, 1);
            
            // Add to inventory
            game.player.inventory.push(braceletToRemove);
            
            // Remove effects
            if (braceletData && braceletData.mana) {
                game.player.maxMana -= braceletData.mana;
                game.player.mana = Math.min(game.player.mana, game.player.maxMana);
            }
            
            speak(`You removed the ${braceletToRemove} and placed it in your inventory.`);
        }

        // ------------------------------------------------------------
        // END OF PIECE 7
        // Piece 8 will contain: Ability Books, Status, Inventory,
        // Help Commands, and Process Command Router
        // ------------------------------------------------------------
       //  ------------------------------------------------------------
        // SECTION 63: READ ABILITY BOOK
        // ------------------------------------------------------------
        
        function readBook(command) {
            // Find ability book in inventory
            let bookToRead = null;
            let abilityToLearn = null;
            
            for (let ability of abilities) {
                const bookName = `Book of ${ability.name}`;
                if (command.includes(ability.name.toLowerCase()) || command.includes(bookName.toLowerCase())) {
                    if (game.player.inventory.includes(bookName)) {
                        bookToRead = bookName;
                        abilityToLearn = ability;
                        break;
                    }
                }
            }
            
            if (!bookToRead) {
                // List available books
                const ownedBooks = game.player.inventory.filter(item => item.startsWith('Book of'));
                if (ownedBooks.length === 0) {
                    speak('You have no ability books. Find them in treasure chests.');
                } else {
                    speak(`You have: ${ownedBooks.join(', ')}. Say read followed by the spell name.`);
                }
                return;
            }
            
            // Check if already learned
            if (game.player.learnedAbilities.includes(abilityToLearn.name)) {
                speak(`You already know ${abilityToLearn.name}.`);
                return;
            }
            
            // Check class restriction
            if (abilityToLearn.class && abilityToLearn.class !== game.player.class) {
                speak(`${abilityToLearn.name} is not for your class. You can sell the book to a merchant.`);
                return;
            }
            
            // Learn the ability
            const index = game.player.inventory.indexOf(bookToRead);
            game.player.inventory.splice(index, 1);
            game.player.learnedAbilities.push(abilityToLearn.name);
            
            speakSequence([
                `You study the ${bookToRead} intently.`,
                `You learned ${abilityToLearn.name}!`,
                `${abilityToLearn.description}`,
                `Costs ${abilityToLearn.cost} mana to cast.`
            ]);
        }

        // ------------------------------------------------------------
        // SECTION 64: UNLEARN ABILITY
        // ------------------------------------------------------------
        
        function unlearnAbility(command) {
            if (game.player.learnedAbilities.length === 0) {
                speak('You have no learned abilities to forget.');
                return;
            }
            
            let abilityToForget = null;
            for (let abilityName of game.player.learnedAbilities) {
                if (command.includes(abilityName.toLowerCase())) {
                    abilityToForget = abilityName;
                    break;
                }
            }
            
            if (!abilityToForget) {
                const abilityList = game.player.learnedAbilities.join(', ');
                speak(`Which ability? You know: ${abilityList}`);
                return;
            }
            
            // Remove ability
            const index = game.player.learnedAbilities.indexOf(abilityToForget);
            game.player.learnedAbilities.splice(index, 1);
            
            // Return book to inventory
            const bookName = `Book of ${abilityToForget}`;
            game.player.inventory.push(bookName);
            
            speak(`You forgot ${abilityToForget}. The ${bookName} has been returned to your inventory.`);
        }

        // ------------------------------------------------------------
        // SECTION 65: CHARACTER STATUS
        // ------------------------------------------------------------
        
        function characterStatus() {
            const messages = [];
            
            // Basic info
            messages.push(`You are a level ${game.player.level} ${game.player.class}.`);
            messages.push(`Health: ${game.player.health} of ${game.player.maxHealth}.`);
            messages.push(`Mana: ${game.player.mana} of ${game.player.maxMana}.`);
            messages.push(`Gold: ${game.player.gold}.`);
            messages.push(`Experience: ${game.player.experience} of ${game.player.experienceToNext} to next level.`);
            
            // Calculate attack
            let totalAttack = game.player.baseAttack;
            if (game.player.weapon) {
                const weaponData = weapons.find(w => w.name === game.player.weapon);
                if (weaponData) totalAttack = weaponData.attack;
            }
            if (game.player.gloves) {
                const gloveData = gloves.find(g => g.name === game.player.gloves);
                if (gloveData && gloveData.attack) totalAttack += gloveData.attack;
            }
            // Add bracelet attack bonuses
            for (let braceletName of game.player.equippedBracelets) {
                const braceletData = bracelets.find(b => b.name === braceletName);
                if (braceletData && braceletData.attack) totalAttack += braceletData.attack;
            }
            totalAttack += (game.player.level - 1) * 5;
            totalAttack = Math.floor(totalAttack * game.player.damageMultiplier);
            
            messages.push(`Attack: ${totalAttack}. Defense: ${game.player.defense}.`);
            
            // Equipment
            if (game.player.weapon) messages.push(`Weapon: ${game.player.weapon}.`);
            if (game.player.armor) messages.push(`Armor: ${game.player.armor}.`);
            if (game.player.shield) messages.push(`Shield: ${game.player.shield}.`);
            if (game.player.helmet) messages.push(`Helmet: ${game.player.helmet}.`);
            if (game.player.gloves) messages.push(`Gloves: ${game.player.gloves}.`);
            if (game.player.boots) messages.push(`Boots: ${game.player.boots}.`);
            
            // Rings
            if (game.player.equippedRings.length > 0) {
                messages.push(`Rings: ${game.player.equippedRings.join(', ')}.`);
            }
            
            // Bracelets
            if (game.player.equippedBracelets.length > 0) {
                messages.push(`Bracelets: ${game.player.equippedBracelets.join(', ')}.`);
            }
            
            // Amulet
            if (game.player.equippedAmulet) {
                messages.push(`Amulet: ${game.player.equippedAmulet}.`);
            }
            
            // Learned abilities
            if (game.player.learnedAbilities.length > 0) {
                messages.push(`Spells: ${game.player.learnedAbilities.join(', ')}.`);
            }
            
            // Special items
            if (game.player.specialItems.length > 0) {
                messages.push(`Special items: ${game.player.specialItems.join(', ')}.`);
            }
            
            // Active effects
            if (game.player.activeEffects.length > 0) {
                const effectNames = game.player.activeEffects.map(e => {
                    if (e.type === 'revive') return 'Immortality (1 revive)';
                    if (e.type === 'strength') return `Giant Strength (${e.battles} battles)`;
                    if (e.type === 'clarity') return `Clarity (${e.battles} battles)`;
                    return e.type;
                });
                messages.push(`Active effects: ${effectNames.join(', ')}.`);
            }
            
            // Floor multipliers (if past floor 10)
            if (game.dungeon.currentLevel >= 10) {
                messages.push(`Floor ${game.dungeon.currentLevel} multipliers: Damage x${game.player.damageMultiplier}, Defense x${game.player.defenseMultiplier}.`);
            }
            
            messages.push(`Dungeon level: ${game.dungeon.currentLevel}.`);
            
            speakSequence(messages);
        }

        // ------------------------------------------------------------
        // SECTION 66: LIST INVENTORY
        // ------------------------------------------------------------
        
        function listInventory() {
            if (game.player.inventory.length === 0) {
                speak('Your inventory is empty.');
                return;
            }
            
            const messages = ['Your inventory contains:'];
            
            // Count duplicate items
            const itemCounts = {};
            for (let item of game.player.inventory) {
                itemCounts[item] = (itemCounts[item] || 0) + 1;
            }
            
            // Group by type
            const potions = [];
            const equipment = [];
            const books = [];
            const rings = [];
            const amulets = [];
            const treasures = [];
            const other = [];
            
            for (let [item, count] of Object.entries(itemCounts)) {
                const itemText = count > 1 ? `${item} x${count}` : item;
                
                if (item.includes('Potion') || item.includes('Elixir')) {
                    potions.push(itemText);
                } else if (item.startsWith('Book of')) {
                    books.push(itemText);
                } else if (item.includes('Ring of')) {
                    rings.push(itemText);
                } else if (item.includes('Amulet')) {
                    amulets.push(itemText);
                } else if (weapons.some(w => w.name === item) || 
                           armors.some(a => a.name === item) ||
                           shields.some(s => s.name === item) ||
                           helmets.some(h => h.name === item) ||
                           gloves.some(g => g.name === item) ||
                           boots.some(b => b.name === item) ||
                           bracelets.some(br => br.name === item)) {
                    equipment.push(itemText);
                } else if (treasures.some(t => t.name === item)) {
                    treasures.push(itemText);
                } else {
                    other.push(itemText);
                }
            }
            
            if (potions.length > 0) messages.push(`Potions: ${potions.join(', ')}.`);
            if (equipment.length > 0) messages.push(`Equipment: ${equipment.join(', ')}.`);
            if (books.length > 0) messages.push(`Ability books: ${books.join(', ')}.`);
            if (rings.length > 0) messages.push(`Rings: ${rings.join(', ')}.`);
            if (amulets.length > 0) messages.push(`Amulets: ${amulets.join(', ')}.`);
            if (treasures.length > 0) messages.push(`Treasures: ${treasures.join(', ')}.`);
            if (other.length > 0) messages.push(`Other: ${other.join(', ')}.`);
            
            // Junk bag
            if (game.player.junkBag.length > 0) {
                let junkValue = 0;
                for (let junkItem of game.player.junkBag) {
                    const wData = weapons.find(w => w.name === junkItem);
                    const aData = armors.find(a => a.name === junkItem);
                    const sData = shields.find(s => s.name === junkItem);
                    const hData = helmets.find(h => h.name === junkItem);
                    const gData = gloves.find(g => g.name === junkItem);
                    const bData = boots.find(b => b.name === junkItem);
                    const brData = bracelets.find(br => br.name === junkItem);
                    const tData = treasures.find(t => t.name === junkItem);
                    
                    if (wData) junkValue += Math.floor(wData.value * 0.5);
                    else if (aData) junkValue += Math.floor(aData.value * 0.5);
                    else if (sData) junkValue += Math.floor(sData.value * 0.5);
                    else if (hData) junkValue += Math.floor(hData.value * 0.5);
                    else if (gData) junkValue += Math.floor(gData.value * 0.5);
                    else if (bData) junkValue += Math.floor(bData.value * 0.5);
                    else if (brData) junkValue += Math.floor(brData.value * 0.5);
                    else if (tData) junkValue += tData.value;
                }
                messages.push(`Junk bag: ${game.player.junkBag.length} items worth ${junkValue} gold. Say sell junk at merchant.`);
            }
            
            messages.push(`Total items: ${game.player.inventory.length}.`);
            
            speakSequence(messages);
        }

        // ------------------------------------------------------------
        // SECTION 67: SHOW HELP
        // ------------------------------------------------------------
        
        function showHelp() {
            speakSequence([
                'Echo Dungeon is a voice-controlled dungeon crawler.',
                'Tap the screen to activate voice commands.',
                'Movement: Say north, south, east, or west.',
                'Combat: Say attack, defend, special, cast spell, use potion, or flee.',
                'Exploration: Say search, open chest, merchant, stairs, or fountain.',
                'Status: Say status for your stats, inventory for your items.',
                'Equipment: Say equip followed by item name, or wear ring.',
                'Say commands for a full list of available commands.'
            ]);
        }

        // ------------------------------------------------------------
        // SECTION 68: LIST COMMANDS
        // ------------------------------------------------------------
        
        function listCommands() {
            speakSequence([
                'Movement commands: north, south, east, west.',
                'Look commands: look, search, where am I.',
                'Combat commands: attack, defend, special, cast, flee, use potion.',
                'Item commands: inventory, status, equip, wear ring, remove ring, use.',
                'Ability commands: read book, cast spell name, unlearn.',
                'Merchant commands: merchant, buy, what do you have, leave.',
                'Other commands: open chest, drink fountain, go down stairs, meditate.',
                'Junk commands: add to junk, view junk, sell junk, clear junk.',
                'Save commands: save game, load game, list characters, delete character.',
                'Say help for general guidance, or hint for context-specific tips.'
            ]);
        }

        // ------------------------------------------------------------
        // SECTION 69: GIVE HINT
        // ------------------------------------------------------------
        
        function giveHint() {
            const hints = [];
            
            // Context-specific hints
            if (game.combat) {
                if (game.player.health < game.player.maxHealth * 0.3) {
                    hints.push('Your health is critical! Use a health potion or flee!');
                }
                if (game.player.mana >= 20 && game.player.learnedAbilities.length > 0) {
                    hints.push(`You can cast ${game.player.learnedAbilities[0]} for extra damage.`);
                }
                if (game.combat.enemy.health < game.combat.enemy.health * 0.2) {
                    hints.push('The enemy is nearly defeated! One more attack should do it.');
                }
            } else {
                if (game.currentRoom && game.currentRoom.type === 'merchant') {
                    hints.push('Say merchant to open the shop. The merchant buys items at half price.');
                }
                if (game.currentRoom && game.currentRoom.type === 'fountain' && !game.currentRoom.fountainUsed) {
                    hints.push('Say drink fountain or swim to fully restore health and mana!');
                }
                if (game.currentRoom && game.currentRoom.type === 'stairs') {
                    hints.push('Say go down stairs to descend to the next dungeon level.');
                }
                if (game.currentRoom && game.currentRoom.hasChest && !game.currentRoom.searched) {
                    hints.push('There is a chest here! Say open chest to loot it.');
                }
                if (game.player.inventory.length > 15) {
                    hints.push('Your inventory is getting full. Consider selling items to a merchant.');
                }
                if (game.player.health < game.player.maxHealth * 0.5) {
                    hints.push('Your health is low. Find a fountain or use a health potion.');
                }
            }
            
            // Add a random general tip
            const randomTip = gameInfo.tips[Math.floor(Math.random() * gameInfo.tips.length)];
            hints.push(randomTip);
            
            if (hints.length > 0) {
                speakSequence(hints);
            } else {
                speak('Explore the dungeon, fight enemies, and find treasure! Say help for commands.');
            }
        }

        // ------------------------------------------------------------
        // SECTION 70: SHOW LICENSE
        // ------------------------------------------------------------
        
        function showLicense() {
            speak(gameInfo.license);
        }

        // ------------------------------------------------------------
        // SECTION 71: SHOW README
        // ------------------------------------------------------------
        
        function showReadme() {
            speak(gameInfo.readme);
        }

        // ------------------------------------------------------------
        // SECTION 72: SHOW TIPS
        // ------------------------------------------------------------
        
        function showTips() {
            speakSequence(gameInfo.tips);
        }

        // ------------------------------------------------------------
        // SECTION 73: CALCULATE TOTAL ATTACK
        // ------------------------------------------------------------
        
        function calculateTotalAttack() {
            let totalAttack = game.player.baseAttack;
            
            // Weapon attack
            if (game.player.weapon) {
                const weaponData = weapons.find(w => w.name === game.player.weapon);
                if (weaponData) totalAttack = weaponData.attack;
            }
            
            // Gloves attack bonus
            if (game.player.gloves) {
                const gloveData = gloves.find(g => g.name === game.player.gloves);
                if (gloveData && gloveData.attack) totalAttack += gloveData.attack;
            }
            
            // Bracelet attack bonuses
            for (let braceletName of game.player.equippedBracelets) {
                const braceletData = bracelets.find(b => b.name === braceletName);
                if (braceletData && braceletData.attack) totalAttack += braceletData.attack;
            }
            
            // Level bonus
            totalAttack += (game.player.level - 1) * 5;
            
            // Floor damage multiplier
            totalAttack = Math.floor(totalAttack * game.player.damageMultiplier);
            
            // Strength potion effect
            const strengthEffect = game.player.activeEffects.find(e => e.type === 'strength');
            if (strengthEffect) {
                totalAttack *= 2;
            }
            
            return totalAttack;
        }

        // ------------------------------------------------------------
        // SECTION 74: PROCESS COMMAND - MAIN ROUTER
        // ------------------------------------------------------------
        
        function processCommand(command) {
            // Save/Load commands work in any phase
            if (command.includes('save game') || command.includes('save character') || 
                (command.includes('save') && !command.includes('slot'))) {
                saveGame(command);
                return;
            }
            
            if (command.includes('load game') || command.includes('load character')) {
                loadGame(command);
                return;
            }
            
            if (command.includes('list character') || command.includes('list save') || command.includes('my characters')) {
                listCharacters();
                return;
            }
            
            if (command.includes('delete character') || command.includes('delete save')) {
                deleteCharacter(command);
                return;
            }
            
            // License and info commands
            if (command.includes('license') || command.includes('copyright')) {
                showLicense();
                return;
            }
            
            if (command.includes('readme') || command.includes('read me') || command.includes('how to play')) {
                showReadme();
                return;
            }
            
            if (command.includes('tips') || command.includes('all tips')) {
                showTips();
                return;
            }
            
            // Merchant mode
            if (game.merchantOpen) {
                if (command.includes('leave') || command.includes('exit') || command.includes('close') || command.includes('bye')) {
                    leaveMerchant();
                } else if (command.includes('buy') || command.includes('purchase')) {
                    buyFromMerchant(command);
                } else if (command.includes('what') || command.includes('wares') || command.includes('stock') || command.includes('sell what')) {
                    listMerchantWares();
                } else if (command.includes('sell junk') || command.includes('sell all junk')) {
                    sellAllJunk();
                } else {
                    speak('Say buy followed by item name, what do you have, sell junk, or leave.');
                }
                return;
            }
            
            // Class selection phase
            if (game.needsClass) {
                if (command.includes('warrior') || command.includes('fighter') || command.includes('knight')) {
                    selectClass('warrior');
                } else if (command.includes('mage') || command.includes('wizard') || command.includes('sorcerer')) {
                    selectClass('mage');
                } else if (command.includes('rogue') || command.includes('thief') || command.includes('assassin')) {
                    selectClass('rogue');
                } else {
                    speak('Choose your class: warrior, mage, or rogue. Each has unique abilities and equipment.');
                }
                return;
            }
            
            // Combat phase
            if (game.combat) {
                if (command.includes('attack') || command.includes('hit') || command.includes('strike') || command.includes('fight')) {
                    playerAttack();
                } else if (command.includes('defend') || command.includes('block') || command.includes('guard') || command.includes('brace')) {
                    playerDefend();
                } else if (command.includes('special') || command.includes('ability') || command.includes('power')) {
                    playerSpecial();
                } else if (command.includes('cast') || command.includes('spell')) {
                    castSpell(command);
                } else if (command.includes('potion') || command.includes('heal') || command.includes('drink') || command.includes('use')) {
                    processPotionCommand(command);
                } else if (command.includes('flee') || command.includes('run') || command.includes('escape') || command.includes('retreat')) {
                    attemptFlee();
                } else if (command.includes('status') || command.includes('health') || command.includes('stats')) {
                    speak(`Health: ${game.player.health} of ${game.player.maxHealth}. Mana: ${game.player.mana} of ${game.player.maxMana}. Enemy: ${game.combat.enemy.name} with ${game.combat.enemy.health} health.`);
                } else {
                    speak('In combat! Say attack, defend, special, cast spell, use potion, or flee.');
                }
                return;
            }
            
            // Exploration phase commands
            // Movement
            if (command.includes('north') || command === 'up' || command.includes('forward')) {
                move('north');
            } else if (command.includes('south') || command === 'down' || command.includes('back')) {
                move('south');
            } else if (command.includes('east') || command.includes('right')) {
                move('east');
            } else if (command.includes('west') || command.includes('left')) {
                move('west');
            }
            // Status and inventory
            else if (command.includes('status') || command.includes('stats') || command.includes('check self')) {
                characterStatus();
            } else if (command.includes('inventory') || command.includes('items') || command.includes('bag') || command.includes('backpack')) {
                listInventory();
            }
            // Room interaction
            else if (command.includes('look') || command.includes('around') || command.includes('where')) {
                describeRoom();
            } else if (command.includes('search') || command.includes('examine') || command.includes('investigate')) {
                searchRoom();
            } else if (command.includes('open chest') || command.includes('loot') || command.includes('treasure')) {
                openChest();
            } else if (command.includes('fountain') || command.includes('drink water') || command.includes('swim')) {
                useFountain();
            } else if (command.includes('stairs') || command.includes('descend') || command.includes('go down') || command.includes('next level')) {
                useStairs();
            } else if (command.includes('merchant') || command.includes('shop') || command.includes('trade') || command.includes('store')) {
                talkToMerchant();
            } else if (command.includes('meditate') || command.includes('rest') || command.includes('pray')) {
                meditate();
            } else if (command.includes('lockpick') || command.includes('pick lock') || command.includes('use lockpicks')) {
                useLockpicks();
            }
            // Equipment commands
            else if (command.includes('remove ring') || command.includes('unequip ring') || command.includes('take off ring')) {
                removeRing(command);
            } else if (command.includes('remove bracelet') || command.includes('unequip bracelet') || command.includes('take off bracelet')) {
                removeBracelet(command);
            } else if (command.includes('wear ring') || command.includes('equip ring') || command.includes('put on ring')) {
                equipRing(command);
            } else if (command.includes('wear amulet') || command.includes('equip amulet') || command.includes('put on amulet')) {
                equipAmulet(command);
            } else if (command.includes('wear bracelet') || command.includes('equip bracelet') || command.includes('put on bracelet')) {
                equipBracelet(command);
            } else if (command.includes('equip') || command.includes('wear') || command.includes('wield')) {
                equipItem(command);
            }
            // Ability commands
            else if (command.includes('read book') || command.includes('read') || command.includes('learn') || command.includes('study')) {
                readBook(command);
            } else if (command.includes('unlearn') || command.includes('forget')) {
                unlearnAbility(command);
            }
            // Potion commands (outside combat)
            else if (command.includes('potion') || command.includes('drink') || command.includes('use')) {
                processPotionCommand(command);
            }
            // Junk bag commands
            else if ((command.includes('junk') || command.includes('trash')) && (command.includes('add') || command.includes('put'))) {
                addToJunk(command);
            } else if ((command.includes('junk') || command.includes('trash')) && (command.includes('remove') || command.includes('take'))) {
                removeFromJunk(command);
            } else if (command.includes('sell junk') || command.includes('sell all junk') || command.includes('sell trash')) {
                sellAllJunk();
            } else if (command.includes('view junk') || command.includes('check junk') || command.includes('junk bag')) {
                viewJunk();
            } else if (command.includes('clear junk') || command.includes('empty junk')) {
                clearJunk();
            }
            // Inspect command
            else if (command.includes('inspect') || command.includes('examine item') || command.includes('look at')) {
                inspectItem(command);
            }
            // Help commands
            else if (command.includes('commands') || command.includes('what can i')) {
                listCommands();
            } else if (command.includes('hint') || command.includes('help me') || command.includes('tip')) {
                giveHint();
            } else if (command.includes('help')) {
                showHelp();
            }
            // Unknown command
            else {
                speak('Command not recognized. Say help for guidance or commands for a full list.');
            }
        }

        // ------------------------------------------------------------
        // END OF PIECE 8
        // Piece 9 will contain: DOMContentLoaded, Final Initialization,
        // and closing tags
        // ------------------------------------------------------------
        // ------------------------------------------------------------
        // SECTION 75: UPDATE FLOOR MULTIPLIERS
        // Called when descending past floors 10, 20, 30, etc.
        // ------------------------------------------------------------
        
        function updateFloorMultipliers() {
            const floor = game.dungeon.currentLevel;
            
            // Every 10 floors, double the multipliers
            if (floor % 10 === 0 && floor >= 10) {
                const tier = Math.floor(floor / 10);
                game.player.damageMultiplier = Math.pow(2, tier);
                game.player.defenseMultiplier = Math.pow(2, tier);
                game.player.manaMultiplier = Math.pow(2, tier);
                
                // Recalculate defense with new multiplier
                recalculateDefense();
                
                speakSequence([
                    `Floor ${floor} reached!`,
                    `Your power has grown!`,
                    `Damage multiplier: ${game.player.damageMultiplier}x`,
                    `Defense multiplier: ${game.player.defenseMultiplier}x`,
                    `Enemies will also be stronger!`
                ]);
            }
        }

        // ------------------------------------------------------------
        // SECTION 76: AUTO-SAVE SYSTEM
        // Saves every 5 rooms explored
        // ------------------------------------------------------------
        
        function checkAutoSave() {
            game.saveCounter++;
            if (game.saveCounter >= 5) {
                game.saveCounter = 0;
                // Auto-save to slot 0 (auto-save slot)
                try {
                    const saveData = {
                        version: 'V12',
                        timestamp: Date.now(),
                        player: JSON.parse(JSON.stringify(game.player)),
                        dungeon: {
                            currentLevel: game.dungeon.currentLevel,
                            size: game.dungeon.size
                        },
                        phase: game.phase,
                        autoSave: true
                    };
                    localStorage.setItem('echoDungeon_autoSave', JSON.stringify(saveData));
                } catch (e) {
                    // Silent fail for auto-save
                }
            }
        }

        // ------------------------------------------------------------
        // SECTION 77: LOAD AUTO-SAVE
        // ------------------------------------------------------------
        
        function loadAutoSave() {
            try {
                const saveData = localStorage.getItem('echoDungeon_autoSave');
                if (saveData) {
                    const data = JSON.parse(saveData);
                    if (data.autoSave && data.player) {
                        return data;
                    }
                }
            } catch (e) {
                // Silent fail
            }
            return null;
        }

        // ------------------------------------------------------------
        // SECTION 78: CHECK FOR AUTO-SAVE ON START
        // ------------------------------------------------------------
        
        function checkForAutoSave() {
            const autoSave = loadAutoSave();
            if (autoSave && autoSave.player.class) {
                speakSequence([
                    'An auto-save was found.',
                    `Level ${autoSave.player.level} ${autoSave.player.class} on dungeon floor ${autoSave.dungeon.currentLevel}.`,
                    'Say "continue" to resume or choose a class to start fresh.'
                ]);
                game.hasAutoSave = true;
                game.autoSaveData = autoSave;
            }
        }

        // ------------------------------------------------------------
        // SECTION 79: RESTORE FROM AUTO-SAVE
        // ------------------------------------------------------------
        
        function restoreAutoSave() {
            if (!game.autoSaveData) {
                speak('No auto-save found.');
                return;
            }
            
            const data = game.autoSaveData;
            
            // Restore player
            game.player = data.player;
            
            // Ensure new V12 properties exist
            if (!game.player.equippedBracelets) game.player.equippedBracelets = [];
            if (!game.player.damageMultiplier) game.player.damageMultiplier = 1;
            if (!game.player.defenseMultiplier) game.player.defenseMultiplier = 1;
            if (!game.player.manaMultiplier) game.player.manaMultiplier = 1;
            
            // Restore dungeon level
            game.dungeon.currentLevel = data.dungeon.currentLevel;
            
            // Generate fresh dungeon for current level
            generateDungeon();
            
            // Set game state
            game.needsClass = false;
            game.started = true;
            game.phase = 'exploration';
            game.hasAutoSave = false;
            game.autoSaveData = null;
            
            speakSequence([
                'Auto-save restored!',
                `Welcome back, ${game.player.class}.`,
                `Level ${game.player.level}, Floor ${game.dungeon.currentLevel}.`,
                `Health: ${game.player.health}. Gold: ${game.player.gold}.`
            ], () => {
                setTimeout(() => describeRoom(), 1000);
            });
        }

        // ------------------------------------------------------------
        // SECTION 80: ENHANCED HANDLE CLICK
        // Replaces the basic handleClick with auto-save support
        // ------------------------------------------------------------
        
        function handleClickEnhanced() {
            if (!game.started && !game.needsClass) {
                // First click - initialize
                game.needsClass = true;
                game.started = false;
                
                checkForAutoSave();
                
                if (!game.hasAutoSave) {
                    speakSequence([
                        'Welcome to Echo Dungeon Version 12.',
                        'A voice-controlled adventure for blind players.',
                        'Choose your class: Warrior, Mage, or Rogue.',
                        'Or say "load game" to continue a saved character.'
                    ]);
                }
                return;
            }
            
            // Check for continue command after finding auto-save
            if (game.hasAutoSave) {
                // Will be handled by processCommand
            }
            
            startListening();
        }

        // ------------------------------------------------------------
        // SECTION 81: EXTENDED PROCESS COMMAND
        // Adds continue command for auto-save
        // ------------------------------------------------------------
        // SECTION 81: HANDLE CONTINUE COMMAND
        // Checks for auto-save restore before processing
        // ------------------------------------------------------------
        
        function handleCommand(command) {
            // Check for continue/resume command for auto-save
            if (game.hasAutoSave && (command.includes('continue') || command.includes('resume') || command.includes('restore'))) {
                restoreAutoSave();
                return;
            }
            
            // Process normally
            processCommand(command);
        }

        // ------------------------------------------------------------
        // SECTION 82: BROWSER COMPATIBILITY CHECK
        // ------------------------------------------------------------
        
        function showCompatibilityWarning() {
            if (!browserSupport.speechSynthesis) {
                console.warn('Speech synthesis not supported in this browser.');
            }
            if (!browserSupport.speechRecognition) {
                console.warn('Speech recognition not supported. Try Chrome or Edge.');
            }
            if (!browserSupport.https && window.location.hostname !== 'localhost') {
                console.warn('HTTPS required for speech recognition.');
            }
        }

        // ------------------------------------------------------------
        // SECTION 83: KEYBOARD FALLBACK
        // For testing without voice
        // ------------------------------------------------------------
        
        function setupKeyboardFallback() {
            document.addEventListener('keydown', (e) => {
                // Press Enter to activate voice
                if (e.key === 'Enter') {
                    handleClickEnhanced();
                }
                // Press Escape to stop listening
                if (e.key === 'Escape') {
                    stopListening();
                }
            });
        }

        // ------------------------------------------------------------
        // SECTION 84: DEBUG LOGGING (Disabled by default)
        // ------------------------------------------------------------
        
        const DEBUG_MODE = false;
        
        function debugLog(message) {
            if (DEBUG_MODE) {
                console.log(`[Echo Dungeon] ${message}`);
            }
        }

        // ------------------------------------------------------------
        // SECTION 85: PERFORMANCE MONITOR
        // Cleans up old data on deep dungeon runs
        // ------------------------------------------------------------
        
        function performanceCheck() {
            // Clean up if inventory gets too large
            if (game.player.inventory.length > 100) {
                debugLog('Large inventory detected. Consider selling items.');
            }
            
            // Clean up old room data every 50 floors
            if (game.dungeon.currentLevel % 50 === 0 && game.dungeon.currentLevel > 0) {
                debugLog('Deep dungeon milestone. Memory optimized.');
            }
        }

        // ------------------------------------------------------------
        // SECTION 86: SIMPLE INITIALIZATION (V10.5 STYLE)
        // ------------------------------------------------------------
        
        function initializeGame() {
            game.initialized = true;
            micButton.classList.remove('start-button');
            speak("Welcome to Echo Dungeon V12! Say load game to continue, or choose your class: warrior, mage, or rogue.");
        }

        function handleClick() {
            if (!game.initialized) {
                initializeGame();
            } else {
                startListening();
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            checkBrowserSupport();
            setTimeout(function() {
                speak('Echo Dungeon V12 is ready. Tap the screen to begin.');
            }, 1000);
        });

        micButton.addEventListener('contextmenu', function(e) { e.preventDefault(); });
    </script>
</body>
</html>




